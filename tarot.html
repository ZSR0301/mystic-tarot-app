<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Tarot: Gesture & Particle System</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="card-popup.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-image: url('background.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            font-family: 'Segoe UI', sans-serif;
        }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        
        /* é¡¶éƒ¨çŠ¶æ€æ  */
        .header { display: flex; justify-content: space-between; align-items: flex-start; }
        .status-box {
            background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px; border: 1px solid #444; color: #fff;
            max-width: 300px; backdrop-filter: blur(5px);
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #d4af37; }
        #gesture-indicator { font-weight: bold; color: #00ffcc; }
        
        /* å†å²è®°å½• */
        #history-panel {
            background: rgba(0, 0, 0, 0.7); width: 280px; height: 60vh; overflow-y: auto;
            border-right: 1px solid #444; pointer-events: auto; padding: 10px;
        }
        .history-item {
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            font-size: 0.9rem;
            color: #ccc;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            transition: all 0.3s ease;
        }
        .history-item:hover {
            background: rgba(212, 175, 55, 0.1);
            transform: translateX(5px);
        }
        .history-card-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .history-card-image {
            width: 50px;
            height: 70px;
            object-fit: cover;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid #d4af37;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        .history-card-info {
            flex: 1;
        }
        .history-card-name {
            font-weight: bold;
            color: #d4af37;
            margin-bottom: 3px;
            font-size: 0.9rem;
        }
        .history-card-position {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 3px;
        }
        .history-card-meaning {
            font-size: 0.8rem;
            line-height: 1.3;
        }
        .history-rev {
            color: #ff6b6b;
            font-size: 0.8rem;
        }
        .history-up {
            color: #6bcf7f;
            font-size: 0.8rem;
        }
        .history-timestamp {
            font-size: 0.7rem;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }
        
        /* åº•éƒ¨æ§åˆ¶ */
        .controls { pointer-events: auto; text-align: center; }
        button {
            background: #d4af37; border: none; padding: 10px 20px; color: #000; font-weight: bold; cursor: pointer; border-radius: 4px;
            transition: 0.3s;
        }
        button:hover { background: #fff; }

        /* éšè—çš„è§†é¢‘å…ƒç´  */
        #input-video { display: none; }
        
        /* æ‘„åƒå¤´å°çª—å£ */
        #camera-preview {
            position: fixed; bottom: 20px; right: 20px; width: 200px; height: 150px;
            background: rgba(0, 0, 0, 0.8); border: 2px solid #d4af37; border-radius: 8px;
            overflow: hidden; z-index: 1000; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        #camera-preview.active {
            display: block;
        }
        #camera-preview video {
            width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);
        }
        #camera-preview .toggle-btn {
            position: absolute; top: 5px; right: 5px; background: rgba(212, 175, 55, 0.8);
            border: none; width: 24px; height: 24px; border-radius: 50%; color: #000;
            font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        #camera-preview .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.9);
        }
        
        /* é¼ æ ‡/æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #cursor-indicator {
            position: fixed; width: 20px; height: 20px; border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.8) 0%, rgba(212, 175, 55, 0.3) 70%, transparent 100%);
            border: 2px solid #d4af37; pointer-events: none; z-index: 999;
            transform: translate(-50%, -50%); transition: all 0.1s ease-out;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }
        #cursor-indicator.active {
            animation: pulse 1.5s infinite;
        }
        #cursor-indicator.pinch {
            background: radial-gradient(circle, rgba(255, 255, 0, 0.9) 0%, rgba(255, 255, 0, 0.4) 70%, transparent 100%);
            border-color: #ffff00;
            transform: translate(-50%, -50%) scale(1.2);
        }
        #cursor-indicator.fist {
            background: radial-gradient(circle, rgba(255, 0, 0, 0.9) 0%, rgba(255, 0, 0, 0.4) 70%, transparent 100%);
            border-color: #ff0000;
            transform: translate(-50%, -50%) scale(1.3);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
            50% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.8), 0 0 30px rgba(212, 175, 55, 0.4); }
            100% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
        }
        
        /* å¡ç‰Œå±•ç¤ºåŒºåŸŸ */
        #card-display-area {
            position: fixed;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 18px;
            z-index: 100;
            pointer-events: none;
        }
        
        .card-slot {
            width: 120px;
            height: 210px;
            position: relative;
            border: 2px dashed rgba(212, 175, 55, 0.6);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .card-slot-inner {
            width: 105px;
            height: 180px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .card-slot-inner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg,
                rgba(212, 175, 55, 0.1) 0%,
                rgba(212, 175, 55, 0.05) 50%,
                rgba(212, 175, 55, 0.1) 100%);
            z-index: -1;
        }
        
        .card-slot-label {
            position: absolute;
            bottom: 10px;
            color: rgba(212, 175, 55, 0.8);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        .card-slot.occupied {
            border-color: rgba(212, 175, 55, 0.9);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }
        
        .card-slot.occupied .card-slot-inner {
            border-color: rgba(212, 175, 55, 0.6);
        }
        
        .card-slot.occupied .card-slot-label {
            color: #d4af37;
        }
        
        /* å¡ç‰Œåœ¨å±•ç¤ºæ¡†ä¸­çš„æ ·å¼ */
        .displayed-card {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 6px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* æ–°ä¸€è½®æŒ‰é’® */
        .new-round-btn {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #d4af37, #b8941f);
            border: none;
            padding: 15px 25px;
            color: #000;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .new-round-btn:hover {
            background: linear-gradient(135deg, #e6c047, #c9a521);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
            transform: translateY(-50%) scale(1.05);
        }
        
        .new-round-btn:active {
            transform: translateY(-50%) scale(0.98);
        }
        
        /* åŠ è½½æç¤º */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 20px; text-align: center;
        }
    </style>
</head>
<body>

    <div id="loader">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br><span style="font-size:14px; color:#888">è¯·å…è®¸æ‘„åƒå¤´æƒé™æˆ–ç‚¹å‡»ä¸‹æ–¹åˆ‡æ¢é¼ æ ‡æ¨¡å¼</span></div>

    <div id="ui-layer">
        <div class="header">
            <div id="history-panel">
                <div style="color:#d4af37; margin-bottom:10px;">ğŸ“œ å‘½è¿è½¨è¿¹</div>
                <div id="history-list"></div>
            </div>
            <div class="status-box">
                <h1>ğŸ”® Mystic Tarot</h1>
                <div>è¾“å…¥æ¨¡å¼: <span id="input-mode">åˆå§‹åŒ–...</span></div>
                <div>æ‰‹åŠ¿: <span id="gesture-indicator">ç­‰å¾…</span></div>
                <div id="card-desc" style="margin-top:10px; font-size:0.9rem; color:#aaa;">è¯·å¼ å¼€æ‰‹æŒä»¥æ¿€æ´»æŠ½ç‰Œ...</div>
            </div>
        </div>
        <div class="controls">
            <button onclick="app.toggleMode()">åˆ‡æ¢ æ‘„åƒå¤´ / é¼ æ ‡ æ¨¡å¼</button>
        </div>
    </div>

    <!-- å¡ç‰Œå±•ç¤ºåŒºåŸŸ -->
    <div id="card-display-area">
        <div class="card-slot" id="card-slot-1">
            <div class="card-slot-inner"></div>
            <div class="card-slot-label">ä½ç½® 1</div>
        </div>
        <div class="card-slot" id="card-slot-2">
            <div class="card-slot-inner"></div>
            <div class="card-slot-label">ä½ç½® 2</div>
        </div>
        <div class="card-slot" id="card-slot-3">
            <div class="card-slot-inner"></div>
            <div class="card-slot-label">ä½ç½® 3</div>
        </div>
    </div>

    <!-- æ–°ä¸€è½®æŒ‰é’® -->
    <div id="new-round-button" class="new-round-btn">
        æ–°ä¸€è½®
    </div>

    <video id="input-video"></video>
    
    <!-- æ‘„åƒå¤´é¢„è§ˆå°çª—å£ -->
    <div id="camera-preview">
        <video id="preview-video" autoplay muted></video>
        <button class="toggle-btn" onclick="app.toggleCameraPreview()">Ã—</button>
    </div>
    
    <!-- é¼ æ ‡/æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
    <div id="cursor-indicator"></div>

<script>
/**
 * æ¨¡å— 1: é…ç½®ä¸æ•°æ® (RWS Data)
 * ä½¿ç”¨ GitHub æ‰˜ç®¡çš„ Rider-Waite å›¾åƒ
 */
const CONFIG = {
    baseUrl: "cards/tarot-json-master/cards/",
    // å®Œæ•´çš„å¤§é˜¿å¡çº³å’Œå°é˜¿å¡çº³ç‰Œç»„
    deck: [
        // å¤§é˜¿å¡çº³
        { id: "m00", name: "The Fool", meaningUp: "æ–°çš„å¼€å§‹ï¼Œå†’é™©", meaningRev: "é²è½ï¼Œè½»ç‡" },
        { id: "m01", name: "The Magician", meaningUp: "åˆ›é€ åŠ›ï¼Œè¡ŒåŠ¨", meaningRev: "æ¬ºéª—ï¼Œæ‰èƒ½æµªè´¹" },
        { id: "m02", name: "The High Priestess", meaningUp: "ç›´è§‰ï¼Œæ½œæ„è¯†", meaningRev: "å‹æŠ‘æƒ…æ„Ÿ" },
        { id: "m03", name: "The Empress", meaningUp: "ä¸°é¥¶ï¼Œæ¯æ€§", meaningRev: "ä¾èµ–ï¼Œåˆ›é€ åŠ›å—é˜»" },
        { id: "m04", name: "The Emperor", meaningUp: "æƒå¨ï¼Œæ§åˆ¶", meaningRev: "ä¸“åˆ¶ï¼ŒåƒµåŒ–" },
        { id: "m05", name: "The Hierophant", meaningUp: "ä¼ ç»Ÿï¼Œä¿¡ä»°", meaningRev: "åå›ï¼Œæ–°æ€æƒ³" },
        { id: "m06", name: "The Lovers", meaningUp: "çˆ±ï¼Œå’Œè°ï¼Œé€‰æ‹©", meaningRev: "ä¸å’Œè°ï¼Œå…³ç³»ç ´è£‚" },
        { id: "m07", name: "The Chariot", meaningUp: "èƒœåˆ©ï¼Œæ„å¿—åŠ›", meaningRev: "å¤±æ§ï¼Œç¼ºä¹æ–¹å‘" },
        { id: "m08", name: "Strength", meaningUp: "å†…åœ¨åŠ›é‡ï¼Œå‹‡æ°”", meaningRev: "è½¯å¼±ï¼Œæ€€ç–‘" },
        { id: "m09", name: "The Hermit", meaningUp: "å†…çœï¼Œå­¤ç‹¬", meaningRev: "å­¤åƒ»ï¼Œæ‹’ç»å»ºè®®" },
        { id: "m10", name: "Wheel of Fortune", meaningUp: "å‘½è¿ï¼Œè½¬æŠ˜ç‚¹", meaningRev: "åè¿æ°”ï¼ŒæŠ—æ‹’å˜åŒ–" },
        { id: "m11", name: "Justice", meaningUp: "å…¬æ­£ï¼ŒçœŸç†", meaningRev: "ä¸å…¬ï¼Œæ¬ºéª—" },
        { id: "m12", name: "The Hanged Man", meaningUp: "ç‰ºç‰²ï¼Œæ–°è§†è§’", meaningRev: "åœæ»ï¼Œè‡ªç§" },
        { id: "m13", name: "Death", meaningUp: "ç»“æŸï¼Œè½¬å˜", meaningRev: "åœæ»ï¼Œæ— æ³•æ”¾æ‰‹" },
        { id: "m14", name: "Temperance", meaningUp: "å¹³è¡¡ï¼Œè€å¿ƒ", meaningRev: "å¤±è¡¡ï¼Œå†²çª" },
        { id: "m15", name: "The Devil", meaningUp: "æŸç¼šï¼Œç‰©è´¨ä¸»ä¹‰", meaningRev: "è§£æ”¾ï¼Œæ‘†è„±æŸç¼š" },
        { id: "m16", name: "The Tower", meaningUp: "çªå˜ï¼Œå¯ç¤º", meaningRev: "é€ƒé¿ç¾éš¾ï¼Œææƒ§å˜åŒ–" },
        { id: "m17", name: "The Star", meaningUp: "å¸Œæœ›ï¼Œçµæ„Ÿ", meaningRev: "ç»æœ›ï¼Œå¤±å»ä¿¡å¿µ" },
        { id: "m18", name: "The Moon", meaningUp: "ç›´è§‰ï¼Œæ½œæ„è¯†", meaningRev: "ææƒ§ï¼Œå›°æƒ‘" },
        { id: "m19", name: "The Sun", meaningUp: "æˆåŠŸï¼Œå–œæ‚¦", meaningRev: "æš‚æ—¶çš„å¿«ä¹ï¼Œè™šå‡çš„æˆåŠŸ" },
        { id: "m20", name: "Judgement", meaningUp: "å®¡åˆ¤ï¼Œé‡ç”Ÿ", meaningRev: "è‡ªæˆ‘æ€€ç–‘ï¼Œé€ƒé¿è´£ä»»" },
        { id: "m21", name: "The World", meaningUp: "å®Œæˆï¼Œæ•´åˆ", meaningRev: "æœªå®Œæˆï¼Œç¼ºä¹é—­ç¯" },
        
        // åœ£æ¯ç‰Œç»„
        { id: "c01", name: "Ace of Cups", meaningUp: "æ–°çš„æƒ…æ„Ÿï¼Œçˆ±", meaningRev: "æƒ…æ„Ÿé˜»å¡ï¼Œç©ºè™š" },
        { id: "c02", name: "Two of Cups", meaningUp: "ä¼™ä¼´å…³ç³»ï¼Œå’Œè°", meaningRev: "å¤±è¡¡ï¼Œå†²çª" },
        { id: "c03", name: "Three of Cups", meaningUp: "åº†ç¥ï¼Œå‹è°Š", meaningRev: "è¿‡åº¦æ”¾çºµï¼Œå­¤ç«‹" },
        { id: "c04", name: "Four of Cups", meaningUp: "ä¸æ»¡ï¼Œé‡æ–°è¯„ä¼°", meaningRev: "æ»¡è¶³ï¼Œå†…çœ" },
        { id: "c05", name: "Five of Cups", meaningUp: "å¤±è½ï¼Œæ‚²ä¼¤", meaningRev: "æ¥å—ï¼Œå‘å‰çœ‹" },
        { id: "c06", name: "Six of Cups", meaningUp: "æ€€æ—§ï¼Œç«¥å¹´", meaningRev: "åœæ»ï¼Œæ´»åœ¨è¿‡å»" },
        { id: "c07", name: "Seven of Cups", meaningUp: "é€‰æ‹©ï¼Œå¹»æƒ³", meaningRev: "å›°æƒ‘ï¼Œä¸åˆ‡å®é™…" },
        { id: "c08", name: "Eight of Cups", meaningUp: "ç¦»å¼€ï¼Œå¯»æ±‚æ›´å¤š", meaningRev: "é€ƒé¿ï¼Œææƒ§æ”¹å˜" },
        { id: "c09", name: "Nine of Cups", meaningUp: "æ»¡è¶³ï¼Œæ„¿æœ›å®ç°", meaningRev: "ä¸æ»¡ï¼Œè´ªå©ª" },
        { id: "c10", name: "Ten of Cups", meaningUp: "å®¶åº­å¹¸ç¦ï¼Œå’Œè°", meaningRev: "å®¶åº­å†²çªï¼Œä¸å’Œè°" },
        { id: "c11", name: "Page of Cups", meaningUp: "æ•æ„Ÿï¼Œç›´è§‰", meaningRev: "æƒ…ç»ªä¸ç¨³å®šï¼Œä¸æˆç†Ÿ" },
        { id: "c12", name: "Knight of Cups", meaningUp: "æµªæ¼«ï¼Œè¿½éšå†…å¿ƒ", meaningRev: "æƒ…ç»ªåŒ–ï¼Œä¸å¯é " },
        { id: "c13", name: "Queen of Cups", meaningUp: "åŒæƒ…ï¼Œç›´è§‰", meaningRev: "è¿‡åº¦æƒ…ç»ªåŒ–ï¼Œä¸å®‰å…¨æ„Ÿ" },
        { id: "c14", name: "King of Cups", meaningUp: "æƒ…æ„Ÿå¹³è¡¡ï¼ŒåŒæƒ…", meaningRev: "æƒ…æ„Ÿæ“çºµï¼Œä¸ç¨³å®š" },
        
        // å®å‰‘ç‰Œç»„
        { id: "s01", name: "Ace of Swords", meaningUp: "æ–°çš„æ€æƒ³ï¼Œçªç ´", meaningRev: "æ··ä¹±ï¼Œæ®‹é…·" },
        { id: "s02", name: "Two of Swords", meaningUp: "çŠ¹è±«ï¼Œé€‰æ‹©å›°éš¾", meaningRev: "é¿å…å†³ç­–ï¼Œåƒµå±€" },
        { id: "s03", name: "Three of Swords", meaningUp: "å¿ƒç¢ï¼Œæ‚²ä¼¤", meaningRev: "æ¢å¤ï¼Œç—›è‹¦ç¼“è§£" },
        { id: "s04", name: "Four of Swords", meaningUp: "ä¼‘æ¯ï¼Œæ¢å¤", meaningRev: "åœæ»ï¼Œç–²åŠ³" },
        { id: "s05", name: "Five of Swords", meaningUp: "å†²çªï¼Œèƒœåˆ©", meaningRev: "å¤±è´¥ï¼Œå±ˆè¾±" },
        { id: "s06", name: "Six of Swords", meaningUp: "è¿‡æ¸¡ï¼Œæ”¹å˜", meaningRev: "æŠ—æ‹’æ”¹å˜ï¼Œæ‹–å»¶" },
        { id: "s07", name: "Seven of Swords", meaningUp: "æ¬ºéª—ï¼Œç­–ç•¥", meaningRev: "è¢«æ­ç©¿ï¼Œåæœ" },
        { id: "s08", name: "Eight of Swords", meaningUp: "æŸç¼šï¼Œé™åˆ¶", meaningRev: "è‡ªæˆ‘è§£æ”¾ï¼Œæ–°è§†è§’" },
        { id: "s09", name: "Nine of Swords", meaningUp: "ç„¦è™‘ï¼Œæ‹…å¿§", meaningRev: "å¸Œæœ›ï¼Œç—›è‹¦ç»“æŸ" },
        { id: "s10", name: "Ten of Swords", meaningUp: "å¤±è´¥ï¼Œç»“å±€", meaningRev: "æ¢å¤ï¼Œæ–°å¼€å§‹" },
        { id: "s11", name: "Page of Swords", meaningUp: "å¥½å¥‡å¿ƒï¼Œæ–°æ€æƒ³", meaningRev: "å…«å¦ï¼Œä¸æˆç†Ÿ" },
        { id: "s12", name: "Knight of Swords", meaningUp: "è¡ŒåŠ¨ï¼Œé›„å¿ƒ", meaningRev: "é²è½ï¼Œå†²åŠ¨" },
        { id: "s13", name: "Queen of Swords", meaningUp: "ç‹¬ç«‹ï¼Œæ´å¯ŸåŠ›", meaningRev: "å­¤ç«‹ï¼Œå†·é…·" },
        { id: "s14", name: "King of Swords", meaningUp: "æ™ºåŠ›ï¼Œæƒå¨", meaningRev: "ä¸“åˆ¶ï¼Œæ“çºµ" },
        
        // æƒæ–ç‰Œç»„
        { id: "w01", name: "Ace of Wands", meaningUp: "æ–°çš„æœºä¼šï¼Œåˆ›é€ åŠ›", meaningRev: "ç¼ºä¹æ–¹å‘ï¼Œå»¶è¿Ÿ" },
        { id: "w02", name: "Two of Wands", meaningUp: "è§„åˆ’ï¼Œæœªæ¥", meaningRev: "ä¸ç¡®å®šï¼Œç¼ºä¹è®¡åˆ’" },
        { id: "w03", name: "Three of Wands", meaningUp: "è¿›å±•ï¼Œæ‰©å¼ ", meaningRev: "éšœç¢ï¼Œå»¶è¿Ÿ" },
        { id: "w04", name: "Four of Wands", meaningUp: "åº†ç¥ï¼Œå’Œè°", meaningRev: "ä¸å’Œè°ï¼Œä¸ç¨³å®š" },
        { id: "w05", name: "Five of Wands", meaningUp: "ç«äº‰ï¼Œå†²çª", meaningRev: "åˆä½œï¼Œé¿å…å†²çª" },
        { id: "w06", name: "Six of Wands", meaningUp: "èƒœåˆ©ï¼Œè®¤å¯", meaningRev: "å¤±è´¥ï¼Œç¼ºä¹è®¤å¯" },
        { id: "w07", name: "Seven of Wands", meaningUp: "é˜²å¾¡ï¼ŒåšæŒ", meaningRev: "æ”¾å¼ƒï¼Œè„†å¼±" },
        { id: "w08", name: "Eight of Wands", meaningUp: "å¿«é€Ÿè¡ŒåŠ¨ï¼Œå˜åŒ–", meaningRev: "å»¶è¿Ÿï¼Œé˜»ç¢" },
        { id: "w09", name: "Nine of Wands", meaningUp: "éŸ§æ€§ï¼ŒåšæŒ", meaningRev: "ç–²æƒ«ï¼Œæ”¾å¼ƒ" },
        { id: "w10", name: "Ten of Wands", meaningUp: "è´Ÿæ‹…ï¼Œè´£ä»»", meaningRev: "å¸ä¸‹è´Ÿæ‹…ï¼Œå§”æ‰˜" },
        { id: "w11", name: "Page of Wands", meaningUp: "æ¢ç´¢ï¼Œçƒ­æƒ…", meaningRev: "ç¼ºä¹æ–¹å‘ï¼Œä¸æˆç†Ÿ" },
        { id: "w12", name: "Knight of Wands", meaningUp: "å†’é™©ï¼Œå†²åŠ¨", meaningRev: "é²è½ï¼Œç¼ºä¹è®¡åˆ’" },
        { id: "w13", name: "Queen of Wands", meaningUp: "è‡ªä¿¡ï¼Œæ´»åŠ›", meaningRev: "ç¼ºä¹è‡ªä¿¡ï¼Œè¿‡åº¦" },
        { id: "w14", name: "King of Wands", meaningUp: "é¢†å¯¼åŠ›ï¼Œæ„¿æ™¯", meaningRev: "ä¸“åˆ¶ï¼Œå‚²æ…¢" },
        
        // æ˜Ÿå¸ç‰Œç»„
        { id: "p01", name: "Ace of Pentacles", meaningUp: "æ–°çš„æœºä¼šï¼Œç¹è£", meaningRev: "é”™å¤±æœºä¼šï¼Œè´¢åŠ¡å›°éš¾" },
        { id: "p02", name: "Two of Pentacles", meaningUp: "å¹³è¡¡ï¼Œé€‚åº”", meaningRev: "å¤±è¡¡ï¼Œç¼ºä¹é€‚åº”" },
        { id: "p03", name: "Three of Pentacles", meaningUp: "å›¢é˜Ÿåˆä½œï¼ŒæŠ€èƒ½", meaningRev: "ç¼ºä¹åˆä½œï¼Œä½è´¨é‡å·¥ä½œ" },
        { id: "p04", name: "Four of Pentacles", meaningUp: "ç¨³å®šï¼Œä¿å®ˆ", meaningRev: "è´ªå©ªï¼Œåå•¬" },
        { id: "p05", name: "Five of Pentacles", meaningUp: "å›°éš¾ï¼Œè´«å›°", meaningRev: "æ¢å¤ï¼Œå¸Œæœ›" },
        { id: "p06", name: "Six of Pentacles", meaningUp: "æ…·æ…¨ï¼Œåˆ†äº«", meaningRev: "å€ºåŠ¡ï¼Œè‡ªç§" },
        { id: "p07", name: "Seven of Pentacles", meaningUp: "è€å¿ƒï¼ŒæŠ•èµ„", meaningRev: "ç¼ºä¹è€å¿ƒï¼Œå¤±è´¥" },
        { id: "p08", name: "Eight of Pentacles", meaningUp: "å­¦å¾’ï¼ŒæŠ€èƒ½", meaningRev: "ç¼ºä¹æŠ€èƒ½ï¼Œæ‡’æƒ°" },
        { id: "p09", name: "Nine of Pentacles", meaningUp: "ç‹¬ç«‹ï¼Œå¯Œè¶³", meaningRev: "ä¾èµ–ï¼Œè´¢åŠ¡ä¸ç¨³å®š" },
        { id: "p10", name: "Ten of Pentacles", meaningUp: "è´¢å¯Œï¼Œå®¶åº­", meaningRev: "è´¢åŠ¡ä¸ç¨³å®šï¼Œå®¶åº­é—®é¢˜" },
        { id: "p11", name: "Page of Pentacles", meaningUp: "å­¦ä¹ ï¼Œæœºä¼š", meaningRev: "ç¼ºä¹å­¦ä¹ ï¼Œé”™å¤±æœºä¼š" },
        { id: "p12", name: "Knight of Pentacles", meaningUp: "å‹¤å¥‹ï¼Œç¨³å®š", meaningRev: "åœæ»ï¼Œç¼ºä¹è¿›å±•" },
        { id: "p13", name: "Queen of Pentacles", meaningUp: "æ»‹å…»ï¼Œå®é™…", meaningRev: "ç¼ºä¹æ»‹å…»ï¼Œä¸å®é™…" },
        { id: "p14", name: "King of Pentacles", meaningUp: "æˆåŠŸï¼Œè´¢å¯Œ", meaningRev: "è´¢åŠ¡ä¸ç¨³å®šï¼Œè´ªå©ª" }
    ],
    placeholder: "cards/tarot-json-master/cards/m00.jpg"
};

/**
 * æ¨¡å— 2: æ ¸å¿ƒåº”ç”¨é€»è¾‘ (App Class)
 */
class TarotApp {
    constructor() {
        this.mode = 'MOUSE'; // 'CAMERA' or 'MOUSE'
        this.state = 'IDLE'; // IDLE, HOVER, GRABBING, LOCKED
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.cardMeshes = []; // å­˜å‚¨æ‰€æœ‰å¡ç‰Œ
        this.selectedCardIndex = -1; // å½“å‰é€‰ä¸­çš„å¡ç‰Œç´¢å¼•
        this.particles = null;
        this.hands = null;
        this.cameraStream = null; // æ‘„åƒå¤´æµ
        this.cameraPreviewVisible = false; // æ‘„åƒå¤´é¢„è§ˆçª—å£å¯è§æ€§
        
        // äº¤äº’æ•°æ®
        this.cursor = { x: 0, y: 0, active: false }; // å½’ä¸€åŒ–åæ ‡ (-1 åˆ° 1)
        this.gestureState = 'OPEN_PALM'; // OPEN_PALM, POINT, PINCH
        this.currentCardData = null;
        this.cursorIndicator = null; // é¼ æ ‡/æ‰‹åŠ¿æŒ‡ç¤ºå™¨
        
        // å¡ç‰Œè½®æ¢ç›¸å…³
        this.lastCursorX = 0; // ä¸Šä¸€æ¬¡çš„å…‰æ ‡Xä½ç½®
        this.isDragging = false; // æ˜¯å¦æ­£åœ¨æ‹–æ‹½
        this.swipeThreshold = 0.3; // æ»‘åŠ¨é˜ˆå€¼
        this.cardPool = []; // å¡ç‰Œæ± ï¼Œç”¨äºè½®æ¢
        this.cardTransitionSpeed = 0.25; // å¡ç‰Œè¿‡æ¸¡åŠ¨ç”»é€Ÿåº¦
        
        // æ‰‹æŒæŒ¥åŠ¨æ£€æµ‹ï¼ˆä»…åœ¨äº”æŒ‡å¼ å¼€æ—¶æœ‰æ•ˆï¼‰
        this.handPositions = []; // æ‰‹æŒä½ç½®å†å²è®°å½•
        this.maxHandHistory = 5; // æœ€å¤§å†å²è®°å½•æ•°é‡
        this.lastSwipeTime = 0; // ä¸Šæ¬¡æŒ¥åŠ¨æ—¶é—´
        this.swipeCooldown = 100; // æŒ¥åŠ¨å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰- å‡å°‘å†·å´æ—¶é—´
        this.handSwipeThreshold = 0.01; // æ‰‹æŒæŒ¥åŠ¨é˜ˆå€¼ - é™ä½é˜ˆå€¼ï¼Œæ›´å®¹æ˜“è§¦å‘
        this.rotationIntensity = 20; // æ¯æ¬¡æŒ¥åŠ¨çš„è½®è½¬å¼ºåº¦ï¼ˆè½®è½¬æ¬¡æ•°ï¼‰
        
        // åŒæ‰‹æŒ¥åŠ¨æ£€æµ‹ï¼ˆè¶…çº§è½®è½¬æ¨¡å¼ï¼‰
        this.doubleHandPositions = []; // åŒæ‰‹ä½ç½®å†å²è®°å½•
        this.maxDoubleHandHistory = 5; // æœ€å¤§å†å²è®°å½•æ•°é‡
        this.lastDoubleSwipeTime = 0; // ä¸Šæ¬¡åŒæ‰‹æŒ¥åŠ¨æ—¶é—´
        this.doubleSwipeCooldown = 50; // åŒæ‰‹æŒ¥åŠ¨å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰- æ›´çŸ­çš„å†·å´æ—¶é—´
        this.doubleHandSwipeThreshold = 0.008; // åŒæ‰‹æŒ¥åŠ¨é˜ˆå€¼ - æ›´ä½çš„é˜ˆå€¼ï¼Œæ›´å®¹æ˜“è§¦å‘
        this.doubleRotationIntensity = 50; // åŒæ‰‹æ¯æ¬¡æŒ¥åŠ¨çš„è½®è½¬å¼ºåº¦ï¼ˆæ›´å¤§çš„è½®è½¬æ¬¡æ•°ï¼‰
        
        // æåˆçŠ¶æ€è·Ÿè¸ª
        this.wasPinching = false; // ä¸Šä¸€æ¬¡æ˜¯å¦å¤„äºæåˆçŠ¶æ€
        this.pinchStartTime = 0; // å¼€å§‹æåˆçš„æ—¶é—´
        this.pinchStartY = 0; // å¼€å§‹æåˆæ—¶çš„Yåæ ‡
        this.pullBackThreshold = 0.15; // å‘åæ‹‰åŠ¨çš„é˜ˆå€¼
        this.pinchConfirmTime = 1000; // æåˆç¡®è®¤æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        
        // ç²’å­ç‰¹æ•ˆç³»ç»Ÿ
        this.rotationParticles = []; // è½®æ¢æ—¶çš„ç²’å­æ•ˆæœ
        
        // å¡ç‰Œå¼¹å‡ºåŠŸèƒ½
        this.cardPopup = new CardPopup();
        
        // å¡ç‰Œå±•ç¤ºæ¡†ç®¡ç†
        this.cardSlots = [
            document.getElementById('card-slot-1'),
            document.getElementById('card-slot-2'),
            document.getElementById('card-slot-3')
        ];
        this.displayedCards = []; // å­˜å‚¨å·²æ˜¾ç¤ºåœ¨å±•ç¤ºæ¡†ä¸­çš„å¡ç‰Œæ•°æ®
        
        this.initThree();
        this.initInput();
        this.initCursorIndicator();
        this.initNewRoundButton();
        this.spawnCardRow();
        this.animate();
    }

    // --- Three.js åˆå§‹åŒ– ---
    initThree() {
        this.scene = new THREE.Scene();
        // è¿·é›¾æ•ˆæœ
        this.scene.fog = new THREE.FogExp2(0x0f0f15, 0.05);

        // åœ¨ initThree() æ–¹æ³•ä¸­æ›¿æ¢åŸæœ‰çš„ camera è®¾ç½®
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.set(0, -5, 12); 
        this.camera.lookAt(0, 0, -15); // çœ‹å‘åœºæ™¯ä¸­å¿ƒç¨å¾®åä¸Šçš„ä½ç½®

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // ç¯å…‰
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        const spot = new THREE.SpotLight(0xd4af37, 1);
        spot.position.set(5, 10, 7);
        spot.castShadow = true;
        this.scene.add(ambient, spot);
        
        // çª—å£ç¼©æ”¾
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
    
    // åˆå§‹åŒ–é¼ æ ‡/æ‰‹åŠ¿æŒ‡ç¤ºå™¨
    initCursorIndicator() {
        this.cursorIndicator = document.getElementById('cursor-indicator');
    }
    
    // æ›´æ–°é¼ æ ‡/æ‰‹åŠ¿æŒ‡ç¤ºå™¨ä½ç½®å’ŒçŠ¶æ€
    updateCursorIndicator() {
        if (!this.cursorIndicator) return;
        
        if (this.cursor.active) {
            // å°†å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
            const screenX = (this.cursor.x + 1) * window.innerWidth / 2;
            const screenY = (1 - this.cursor.y) * window.innerHeight / 2;
            
            this.cursorIndicator.style.left = screenX + 'px';
            this.cursorIndicator.style.top = screenY + 'px';
            this.cursorIndicator.style.display = 'block';
            
            // æ ¹æ®æ‰‹åŠ¿çŠ¶æ€æ›´æ–°æ ·å¼
            this.cursorIndicator.className = '';
            if (this.gesture === 'PINCH') {
                this.cursorIndicator.classList.add('pinch');
            } else if (this.gesture === 'FIST') {
                this.cursorIndicator.classList.add('fist');
            } else {
                this.cursorIndicator.classList.add('active');
            }
        } else {
            this.cursorIndicator.style.display = 'none';
        }
    }
    
    // åˆå§‹åŒ–æ–°ä¸€è½®æŒ‰é’®
    initNewRoundButton() {
        const newRoundButton = document.getElementById('new-round-button');
        if (newRoundButton) {
            newRoundButton.addEventListener('click', () => {
                this.startNewRound();
            });
        }
    }
    
    // å¼€å§‹æ–°ä¸€è½®
    startNewRound() {
        // æ¸…ç©ºæ‰€æœ‰å¡ç‰Œå±•ç¤ºæ¡†
        this.clearAllCardSlots();
        
        // æ¸…ç©ºå‘½è¿è½¨è¿¹é¢æ¿
        const historyList = document.getElementById('history-list');
        if (historyList) {
            historyList.innerHTML = '';
        }
        
        // é‡ç½®å¡ç‰Œæ± 
        this.initCardPool();
        
        // æ¸…é™¤ç°æœ‰å¡ç‰Œ
        this.cardMeshes.forEach(card => this.scene.remove(card.mesh));
        this.cardMeshes = [];
        
        // é‡ç½®é€‰ä¸­çŠ¶æ€
        this.selectedCardIndex = -1;
        
        // é‡æ–°ç”Ÿæˆå¡ç‰Œè¡Œ
        this.spawnCardRow();
        
        // é‡ç½®çŠ¶æ€
        this.state = 'IDLE';
    }
    
    // --- è¾“å…¥å¤„ç† (é¼ æ ‡ + MediaPipe) ---
    initInput() {
        // 1. é¼ æ ‡ç›‘å¬
        window.addEventListener('mousemove', (e) => {
            if (this.mode === 'MOUSE') {
                this.cursor.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.cursor.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.cursor.active = true;
                
                // é¼ æ ‡æ¨¡æ‹Ÿæ‰‹åŠ¿ï¼šæŒ‰ä¸‹å·¦é”®=PINCH(æŠ“å–)ï¼ŒæŒ‰ä¸‹å³é”®=FIST(ç¡®è®¤)
                if (e.buttons === 1) this.gesture = 'PINCH';
                else if (e.buttons === 2) this.gesture = 'FIST';
                else this.gesture = 'OPEN';
                
                // å¤„ç†å¡ç‰Œè½®æ¢
                if (this.gesture === 'PINCH') {
                    if (!this.isDragging) {
                        this.isDragging = true;
                        this.lastCursorX = this.cursor.x;
                    } else {
                        // è®¡ç®—ç§»åŠ¨è·ç¦»
                        const deltaX = this.cursor.x - this.lastCursorX;
                        
                        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ»‘åŠ¨é˜ˆå€¼
                        if (Math.abs(deltaX) > this.swipeThreshold) {
                            if (deltaX > 0) {
                                this.rotateCards('right'); // å‘å³æ»‘åŠ¨ï¼Œå¡ç‰Œå‘å·¦è½®æ¢
                            } else {
                                this.rotateCards('left'); // å‘å·¦æ»‘åŠ¨ï¼Œå¡ç‰Œå‘å³è½®æ¢
                            }
                            this.lastCursorX = this.cursor.x; // é‡ç½®èµ·å§‹ä½ç½®
                        }
                    }
                } else {
                    this.isDragging = false;
                }
                
                this.updateUI();
                this.updateCursorIndicator();
                this.updateCardSelection();
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (this.mode === 'MOUSE') {
                this.gesture = e.button === 0 ? 'PINCH' : 'FIST';
                this.updateUI();
                this.updateCursorIndicator();
                
                if (this.gesture === 'FIST' && this.selectedCardIndex >= 0) {
                    this.selectCard(this.selectedCardIndex);
                }
            }
        });
        
        // æ·»åŠ åŒå‡»äº‹ä»¶æ¥æ˜¾ç¤ºå¡ç‰Œå¼¹å‡ºçª—å£
        window.addEventListener('dblclick', (e) => {
            if (this.mode === 'MOUSE' && this.selectedCardIndex >= 0 && this.selectedCardIndex < this.cardMeshes.length) {
                const selectedCard = this.cardMeshes[this.selectedCardIndex];
                this.cardPopup.show(selectedCard.data);
            }
        });
        
        window.addEventListener('mouseup', () => {
            if (this.mode === 'MOUSE') {
                this.gesture = 'OPEN';
                this.isDragging = false;
                this.updateUI();
                this.updateCursorIndicator();
            }
        });

        // å±è”½å³é”®èœå•
        window.addEventListener('contextmenu', e => e.preventDefault());

        // 2. MediaPipe åˆå§‹åŒ–
        const video = document.getElementById('input-video');
        this.hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        this.hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        
        this.hands.onResults(results => this.onHandResults(results));

        // å°è¯•å¯åŠ¨æ‘„åƒå¤´
        const camera = new Camera(video, {
            onFrame: async () => { await this.hands.send({image: video}); },
            width: 1280, height: 720
        });
        
        camera.start()
            .then(() => {
                this.mode = 'CAMERA';
                document.getElementById('loader').style.display = 'none';
                document.getElementById('input-mode').innerText = "æ‘„åƒå¤´ (MediaPipe)";
                
                // è®¾ç½®æ‘„åƒå¤´é¢„è§ˆ
                this.setupCameraPreview(video.srcObject);
            })
            .catch(err => {
                console.warn("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œåˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼", err);
                this.mode = 'MOUSE';
                document.getElementById('loader').style.display = 'none';
                document.getElementById('input-mode').innerText = "é¼ æ ‡ (é™çº§æ¨¡å¼)";
            });
    }

    onHandResults(results) {
        if (this.mode !== 'CAMERA') return;

        if (results.multiHandLandmarks.length > 0) {
            // æ£€æµ‹æ˜¯å¦æœ‰ä¸¤åªæ‰‹
            const hasTwoHands = results.multiHandLandmarks.length >= 2;
            
            // ä½¿ç”¨ç¬¬ä¸€åªæ‰‹è¿›è¡Œä¸»è¦æ‰‹åŠ¿è¯†åˆ«
            const lm = results.multiHandLandmarks[0];
            
            // åæ ‡æ˜ å°„: 1-x å› ä¸ºæ‘„åƒå¤´æ˜¯é•œåƒçš„
            const currentX = (1 - lm[8].x) * 2 - 1; // é£ŸæŒ‡å°– X
            this.cursor.y = (1 - lm[8].y) * 2 - 1; // é£ŸæŒ‡å°– Y (æ³¨æ„MPåæ ‡ç³»Yå‘ä¸‹ï¼ŒGLå‘ä¸Šï¼Œè¿™é‡Œå¾®è°ƒ)
            // ä¿®æ­£ Y è½´: MP y=0æ˜¯é¡¶éƒ¨(1), y=1æ˜¯åº•éƒ¨(-1) -> (0.5 - y) * 2 ?
            // ç®€å•æ˜ å°„: ThreeJS Yè½´å‘ä¸Šã€‚MP Yè½´å‘ä¸‹ã€‚
            this.cursor.y = -(lm[8].y - 0.5) * 4; // æ‰©å¤§æ´»åŠ¨èŒƒå›´

            // æ‰‹åŠ¿è¯†åˆ«ç®—æ³• - ä¸‰å±‚çŠ¶æ€æœº
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const middleTip = lm[12];
            const ringTip = lm[16];
            const pinkyTip = lm[20];
            const wrist = lm[0];

            // 1. PINCH: é£ŸæŒ‡æ‹‡æŒ‡è·ç¦»
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            // 2. æ£€æµ‹æ‰‹æŒ‡çŠ¶æ€
            const isIndexExtended = this.isFingerExtended(lm, 8); // é£ŸæŒ‡
            const isMiddleExtended = this.isFingerExtended(lm, 12); // ä¸­æŒ‡
            const isRingExtended = this.isFingerExtended(lm, 16); // æ— åæŒ‡
            const isPinkyExtended = this.isFingerExtended(lm, 20); // å°æŒ‡
            
            // æ£€æµ‹ä¸¤åªæ‰‹æ˜¯å¦éƒ½æ˜¯å¼ å¼€çš„æ‰‹æŒ
            let bothHandsOpen = false;
            if (hasTwoHands) {
                const lm2 = results.multiHandLandmarks[1];
                const isIndexExtended2 = this.isFingerExtended(lm2, 8);
                const isMiddleExtended2 = this.isFingerExtended(lm2, 12);
                const isRingExtended2 = this.isFingerExtended(lm2, 16);
                const isPinkyExtended2 = this.isFingerExtended(lm2, 20);
                
                bothHandsOpen = isIndexExtended && isMiddleExtended && isRingExtended && isPinkyExtended &&
                                  isIndexExtended2 && isMiddleExtended2 && isRingExtended2 && isPinkyExtended2;
            }
            
            // çŠ¶æ€æœºé€»è¾‘
            if (bothHandsOpen) {
                // åŒæ‰‹å¼ å¼€ - è¶…çº§è½®è½¬æ¨¡å¼
                this.gestureState = 'DOUBLE_OPEN_PALM';
                this.handleDoubleOpenPalmGesture(results.multiHandLandmarks);
                this.wasPinching = false; // é‡ç½®æåˆçŠ¶æ€
            } else if (pinchDist < 0.08) {
                // æåˆçŠ¶æ€ - æœ€é«˜ä¼˜å…ˆçº§
                this.gestureState = 'PINCH';
                this.handlePinchGesture(lm);
            } else if (isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                // åªæœ‰é£ŸæŒ‡ä¼¸å‡º - ç„å‡†æ¨¡å¼
                this.gestureState = 'POINT';
                this.wasPinching = false; // é‡ç½®æåˆçŠ¶æ€
            } else if (isIndexExtended && isMiddleExtended && isRingExtended && isPinkyExtended) {
                // äº”æŒ‡å¼ å¼€ - æµè§ˆ/è½®è½¬æ¨¡å¼
                this.gestureState = 'OPEN_PALM';
                this.handleOpenPalmGesture(lm);
                this.wasPinching = false; // é‡ç½®æåˆçŠ¶æ€
            } else {
                // å…¶ä»–æ‰‹åŠ¿ï¼Œä¿æŒå½“å‰çŠ¶æ€
                this.wasPinching = false; // é‡ç½®æåˆçŠ¶æ€
            }
            
            this.cursor.x = currentX;
            this.cursor.active = true;
        } else {
            this.cursor.active = false;
            this.isDragging = false;
            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            this.gestureState = 'OPEN_PALM';
            this.wasPinching = false;
            this.handPositions = [];
            this.doubleHandPositions = []; // é‡ç½®åŒæ‰‹ä½ç½®è®°å½•
        }
        this.updateUI();
        this.updateCursorIndicator();
        this.updateCardSelection();
    }
    
    // æ£€æµ‹æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
    isFingerExtended(landmarks, tipIndex) {
        // ç®€å•çš„æ‰‹æŒ‡ä¼¸ç›´æ£€æµ‹ï¼šæŒ‡å°–æ¯”æŒ‡å…³èŠ‚æ›´è¿œç¦»æ‰‹è…•
        const wrist = landmarks[0];
        const tip = landmarks[tipIndex];
        const base = landmarks[tipIndex - 2]; // æŒ‡å…³èŠ‚
        
        // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»å’ŒæŒ‡å…³èŠ‚åˆ°æ‰‹è…•çš„è·ç¦»
        const tipToWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const baseToWrist = Math.hypot(base.x - wrist.x, base.y - wrist.y);
        
        // å¦‚æœæŒ‡å°–æ¯”æŒ‡å…³èŠ‚æ›´è¿œç¦»æ‰‹è…•ï¼Œåˆ™è®¤ä¸ºæ‰‹æŒ‡ä¼¸ç›´
        return tipToWrist > baseToWrist * 1.1;
    }
    
    // å¤„ç†äº”æŒ‡å¼ å¼€æ‰‹åŠ¿ï¼ˆæµè§ˆ/è½®è½¬æ¨¡å¼ï¼‰
    handleOpenPalmGesture(lm) {
        // æ£€æµ‹æ‰‹æŒæŒ¥åŠ¨
        this.detectHandSwipe(lm[0].x);
    }
    
    // å¤„ç†æåˆæ‰‹åŠ¿ï¼ˆæŠ“å–/ç¡®è®¤æ¨¡å¼ï¼‰
    handlePinchGesture(lm) {
        if (this.selectedCardIndex >= 0) {
            // æ£€æŸ¥æ˜¯å¦åˆšåˆšè¿›å…¥PINCHçŠ¶æ€
            if (!this.wasPinching) {
                this.wasPinching = true;
                this.pinchStartTime = Date.now();
                this.pinchStartY = lm[8].y; // è®°å½•å¼€å§‹æåˆæ—¶çš„é£ŸæŒ‡Yåæ ‡
            } else {
                // å·²ç»åœ¨æåˆçŠ¶æ€ï¼Œæ£€æŸ¥ç¡®è®¤æ¡ä»¶
                const currentTime = Date.now();
                const currentY = lm[8].y;
                const deltaY = currentY - this.pinchStartY;
                const pinchDuration = currentTime - this.pinchStartTime;
                
                // ç¡®è®¤æ¡ä»¶ï¼šä¿æŒæåˆ1ç§’æˆ–å‘ä¸‹æ‹–æ‹½è¶…è¿‡é˜ˆå€¼
                if (pinchDuration >= this.pinchConfirmTime || deltaY > this.pullBackThreshold) {
                    this.selectCard(this.selectedCardIndex);
                    // é‡ç½®çŠ¶æ€ï¼Œé¿å…é‡å¤è§¦å‘
                    this.wasPinching = false;
                }
            }
        }
    }
    
    // å¤„ç†åŒæ‰‹å¼ å¼€æ‰‹åŠ¿ï¼ˆè¶…çº§è½®è½¬æ¨¡å¼ï¼‰
    handleDoubleOpenPalmGesture(landmarks) {
        // è®¡ç®—ä¸¤åªæ‰‹çš„å¹³å‡Xä½ç½®
        const hand1X = landmarks[0][0].x; // ç¬¬ä¸€åªæ‰‹çš„æ‰‹è…•ä½ç½®
        const hand2X = landmarks[1][0].x; // ç¬¬äºŒåªæ‰‹çš„æ‰‹è…•ä½ç½®
        const avgX = (hand1X + hand2X) / 2;
        
        // æ£€æµ‹åŒæ‰‹æŒ¥åŠ¨
        this.detectDoubleHandSwipe(avgX);
    }
    
    // æ£€æµ‹æ‰‹æŒæŒ¥åŠ¨ï¼ˆä»…åœ¨äº”æŒ‡å¼ å¼€æ—¶æœ‰æ•ˆï¼‰
    detectHandSwipe(handX) {
        const currentTime = Date.now();
        
        // æ·»åŠ å½“å‰ä½ç½®åˆ°å†å²è®°å½•
        this.handPositions.push({
            x: handX,
            time: currentTime
        });
        
        // é™åˆ¶å†å²è®°å½•é•¿åº¦
        if (this.handPositions.length > this.maxHandHistory) {
            this.handPositions.shift();
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å†å²è®°å½•å’Œå†·å´æ—¶é—´
        if (this.handPositions.length >= 5 && (currentTime - this.lastSwipeTime) > this.swipeCooldown) {
            // è®¡ç®—æœ€è¿‘å‡ ä¸ªä½ç½®çš„å¹³å‡ç§»åŠ¨æ–¹å‘
            const recentPositions = this.handPositions.slice(-5);
            const startX = recentPositions[0].x;
            const endX = recentPositions[recentPositions.length - 1].x;
            const deltaX = endX - startX;
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æŒ¥åŠ¨é˜ˆå€¼
            if (Math.abs(deltaX) > this.handSwipeThreshold) {
                // ç¡®å®šæŒ¥åŠ¨æ–¹å‘
                if (deltaX > 0) {
                    // å‘å³æŒ¥åŠ¨ï¼ˆæ‰‹æŒå‘å³ç§»åŠ¨ï¼‰
                    this.rotateCards('right');
                } else {
                    // å‘å·¦æŒ¥åŠ¨ï¼ˆæ‰‹æŒå‘å·¦ç§»åŠ¨ï¼‰
                    this.rotateCards('left');
                }
                
                // æ›´æ–°ä¸Šæ¬¡æŒ¥åŠ¨æ—¶é—´
                this.lastSwipeTime = currentTime;
                
                // æ¸…ç©ºå†å²è®°å½•ï¼Œé¿å…é‡å¤è§¦å‘
                this.handPositions = [];
            }
        }
    }
    
    // æ£€æµ‹åŒæ‰‹æŒ¥åŠ¨ï¼ˆè¶…çº§è½®è½¬æ¨¡å¼ï¼‰
    detectDoubleHandSwipe(handX) {
        const currentTime = Date.now();
        
        // æ·»åŠ å½“å‰ä½ç½®åˆ°å†å²è®°å½•
        this.doubleHandPositions.push({
            x: handX,
            time: currentTime
        });
        
        // é™åˆ¶å†å²è®°å½•é•¿åº¦
        if (this.doubleHandPositions.length > this.maxDoubleHandHistory) {
            this.doubleHandPositions.shift();
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å†å²è®°å½•å’Œå†·å´æ—¶é—´
        if (this.doubleHandPositions.length >= 5 && (currentTime - this.lastDoubleSwipeTime) > this.doubleSwipeCooldown) {
            // è®¡ç®—æœ€è¿‘å‡ ä¸ªä½ç½®çš„å¹³å‡ç§»åŠ¨æ–¹å‘
            const recentPositions = this.doubleHandPositions.slice(-5);
            const startX = recentPositions[0].x;
            const endX = recentPositions[recentPositions.length - 1].x;
            const deltaX = endX - startX;
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°åŒæ‰‹æŒ¥åŠ¨é˜ˆå€¼
            if (Math.abs(deltaX) > this.doubleHandSwipeThreshold) {
                // ç¡®å®šæŒ¥åŠ¨æ–¹å‘
                if (deltaX > 0) {
                    // å‘å³æŒ¥åŠ¨ï¼ˆåŒæ‰‹å‘å³ç§»åŠ¨ï¼‰
                    this.rotateCards('right', true); // ä¼ é€’trueè¡¨ç¤ºè¶…çº§è½®è½¬æ¨¡å¼
                } else {
                    // å‘å·¦æŒ¥åŠ¨ï¼ˆåŒæ‰‹å‘å·¦ç§»åŠ¨ï¼‰
                    this.rotateCards('left', true); // ä¼ é€’trueè¡¨ç¤ºè¶…çº§è½®è½¬æ¨¡å¼
                }
                
                // æ›´æ–°ä¸Šæ¬¡åŒæ‰‹æŒ¥åŠ¨æ—¶é—´
                this.lastDoubleSwipeTime = currentTime;
                
                // æ¸…ç©ºå†å²è®°å½•ï¼Œé¿å…é‡å¤è§¦å‘
                this.doubleHandPositions = [];
            }
        }
    }

    // --- ä¸šåŠ¡é€»è¾‘ ---
    
    // ç”Ÿæˆæ¡Œé¢æ‰‡å½¢å±•å¼€å¸ƒå±€
    spawnCardRow() {
        // æ¸…é™¤ç°æœ‰å¡ç‰Œ
        this.cardMeshes.forEach(card => this.scene.remove(card.mesh));
        this.cardMeshes = [];
        
        // åˆå§‹åŒ–å¡ç‰Œæ± 
        this.initCardPool();
        
        // æ¡Œé¢æ‰‡å½¢å±•å¼€å‚æ•°
        const cardCount = Math.min(12, CONFIG.deck.length); // é€‚ä¸­çš„å¡ç‰Œæ•°é‡
        const pivotY = -20; // åœ†å¿ƒé”šç‚¹ï¼šå±å¹•åº•éƒ¨å¯è§†åŒºåŸŸä¸‹æ–¹ï¼ˆä¸‹ç§»æ›´å¤šï¼‰
        const radius = 15; // è¾ƒå¤§çš„åŠå¾„ï¼Œä½¿å¼§åº¦å‘ˆç°ä¸ºå¹³ç¼“çš„æ‹±å½¢
        const centerX = 0; // åœ†å¿ƒXåæ ‡
        
        // è§’åº¦èŒƒå›´ï¼šä»45åº¦åˆ°135åº¦ï¼ˆä»å·¦ä¸Šåˆ°å³ä¸Šï¼‰
        const startAngle = 45 * Math.PI / 180; // 45åº¦è½¬å¼§åº¦
        const endAngle = 135 * Math.PI / 180; // 135åº¦è½¬å¼§åº¦
        const angleRange = endAngle - startAngle;
        const angleStep = angleRange / (cardCount - 1);
        
        for (let i = 0; i < cardCount; i++) {
            // ä»å¡ç‰Œæ± ä¸­è·å–å¡ç‰Œæ•°æ®
            const cardData = this.getCardFromPool();
            const isReversed = Math.random() < 0.5;
            
            // åˆ›å»ºå¡ç‰Œï¼ˆç‰Œé¢æœä¸‹ï¼‰
            const card = this.createCardMesh(cardData, isReversed, true);
            
            // è®¡ç®—å½“å‰å¡ç‰Œçš„è§’åº¦
            const angle = startAngle + angleStep * i;
            
            // ä½¿ç”¨æåæ ‡å…¬å¼è®¡ç®—ä½ç½®
            const x = centerX + radius * Math.cos(angle);
            const y = pivotY + radius * Math.sin(angle);
            const z = i * 0.001; // å¾®å°çš„Zè½´é€’å¢ï¼Œé˜²æ­¢Z-fighting
            
            // è®¾ç½®ä½ç½®
            const position = new THREE.Vector3(x, y, z);
            card.mesh.position.copy(position);
            
            // è‡ªæ—‹è§’åº¦ï¼šZè½´æ—‹è½¬å‚ç›´äºåœ†åŠå¾„
            // å…¬å¼ï¼šangle - 90åº¦ï¼Œè®©ç‰Œçš„é¡¶éƒ¨æŒ‡å‘å¤–ä¾§
            card.mesh.rotation.z = angle - Math.PI / 2;
            card.mesh.rotation.y = 0; // ä¸è¿›è¡ŒYè½´æ—‹è½¬
            card.mesh.rotation.x = 0; // ä¸è¿›è¡ŒXè½´æ—‹è½¬
            
            // æ·»åŠ åˆ°åœºæ™¯å’Œæ•°ç»„
            this.scene.add(card.mesh);
            this.cardMeshes.push({
                mesh: card.mesh,
                data: { ...cardData, isReversed },
                originalPosition: position.clone(),
                originalRotation: card.mesh.rotation.clone(),
                index: i,
                targetPosition: position.clone(),
                targetRotation: card.mesh.rotation.clone(),
                isTransitioning: false,
                isFaceDown: true, // æ ‡è®°ä¸ºç‰Œé¢æœä¸‹
                isSelected: false // æ ‡è®°æ˜¯å¦è¢«é€‰ä¸­
            });
        }
        
        // é»˜è®¤é€‰ä¸­ä¸­é—´çš„å¡ç‰Œ
        this.selectedCardIndex = Math.floor(cardCount / 2);
        this.updateCardHighlight();
    }
    
    // åˆå§‹åŒ–å¡ç‰Œæ± 
    initCardPool() {
        // åˆ›å»ºå¡ç‰Œæ± çš„å‰¯æœ¬
        this.cardPool = [...CONFIG.deck];
        // éšæœºæ‰“ä¹±å¡ç‰Œæ± 
        for (let i = this.cardPool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cardPool[i], this.cardPool[j]] = [this.cardPool[j], this.cardPool[i]];
        }
    }
    
    // ä»å¡ç‰Œæ± ä¸­è·å–å¡ç‰Œ
    getCardFromPool() {
        if (this.cardPool.length === 0) {
            // å¦‚æœå¡ç‰Œæ± ä¸ºç©ºï¼Œé‡æ–°åˆå§‹åŒ–
            this.initCardPool();
        }
        return this.cardPool.pop();
    }
    
    // è½®æ¢å¡ç‰Œï¼ˆé€‚åº”æ¡Œé¢æ‰‡å½¢å±•å¼€å¸ƒå±€ï¼‰
    rotateCards(direction, isSuperRotation = false) {
        if (this.cardMeshes.length === 0) return;
        
        // ä¿å­˜å½“å‰å·²é€‰ä¸­çš„å¡ç‰Œæ•°é‡
        const selectedCount = this.cardMeshes.filter(card => card.isSelected).length;
        
        // æ ¹æ®æ˜¯å¦æ˜¯è¶…çº§è½®è½¬æ¨¡å¼è®¾ç½®å‚æ•°
        const rotationCount = isSuperRotation ? this.doubleRotationIntensity : this.rotationIntensity;
        
        const cardCount = this.cardMeshes.length;
        const pivotY = -20; // åœ†å¿ƒé”šç‚¹ï¼šå±å¹•åº•éƒ¨å¯è§†åŒºåŸŸä¸‹æ–¹ï¼ˆä¸‹ç§»æ›´å¤šï¼‰
        const radius = 15; // è¾ƒå¤§çš„åŠå¾„ï¼Œä½¿å¼§åº¦å‘ˆç°ä¸ºå¹³ç¼“çš„æ‹±å½¢
        const centerX = 0; // åœ†å¿ƒXåæ ‡
        
        // è§’åº¦èŒƒå›´ï¼šä»45åº¦åˆ°135åº¦ï¼ˆä»å·¦ä¸Šåˆ°å³ä¸Šï¼‰
        const startAngle = 45 * Math.PI / 180; // 45åº¦è½¬å¼§åº¦
        const endAngle = 135 * Math.PI / 180; // 135åº¦è½¬å¼§åº¦
        const angleRange = endAngle - startAngle;
        const angleStep = angleRange / (cardCount - 1);
        
        if (direction === 'left') {
            // å‘å·¦è½®æ¢ï¼šç¬¬ä¸€å¼ å¡ç‰Œç§»åˆ°æœ€åï¼Œå¹¶æ›¿æ¢ä¸ºæ–°å¡ç‰Œ
            const firstCard = this.cardMeshes.shift();
            
            // åˆ›å»ºç²’å­æ•ˆæœ
            this.createRotationParticles(firstCard.mesh.position, 'left', isSuperRotation);
            
            // åœ¨æ»‘åŠ¨è¿‡ç¨‹ä¸­åˆ›å»ºé¢å¤–çš„ç²’å­è½¨è¿¹
            this.createSwipeParticles(firstCard.mesh.position, 'left', isSuperRotation);
            
            // å°†ç¬¬ä¸€å¼ å¡ç‰Œç§»å‡ºå±å¹•å·¦ä¾§ï¼Œå¹¶è®¾ç½®æ·¡å‡ºæ•ˆæœ
            const leftAngle = startAngle - 0.1; // è¶…å‡ºæ‰‡å½¢èŒƒå›´
            const leftX = centerX + radius * Math.cos(leftAngle);
            const leftY = pivotY + radius * Math.sin(leftAngle);
            firstCard.targetPosition = new THREE.Vector3(leftX, leftY, firstCard.mesh.position.z);
            firstCard.targetRotation = new THREE.Euler(0, 0, leftAngle - Math.PI / 2); // Zè½´æ—‹è½¬å‚ç›´äºåœ†åŠå¾„
            firstCard.isTransitioning = true;
            firstCard.isFadingOut = true;
            firstCard.opacity = 1.0;
            
            // åˆ›å»ºæ–°å¡ç‰Œï¼ˆç‰Œé¢æœä¸‹ï¼‰
            const newCardData = this.getCardFromPool();
            const isReversed = Math.random() < 0.5;
            const newCard = this.createCardMesh(newCardData, isReversed, true);
            
            // è®¾ç½®æ–°å¡ç‰Œä½ç½®ï¼ˆä»å³ä¾§è¿›å…¥ï¼‰ï¼Œå¹¶è®¾ç½®æ·¡å…¥æ•ˆæœ
            const rightAngle = endAngle + 0.1; // è¶…å‡ºæ‰‡å½¢èŒƒå›´
            const rightX = centerX + radius * Math.cos(rightAngle);
            const rightY = pivotY + radius * Math.sin(rightAngle);
            const newPosition = new THREE.Vector3(rightX, rightY, cardCount * 0.001);
            newCard.mesh.position.copy(newPosition);
            newCard.mesh.rotation.z = rightAngle - Math.PI / 2; // Zè½´æ—‹è½¬å‚ç›´äºåœ†åŠå¾„
            newCard.mesh.rotation.y = 0; // ä¸è¿›è¡ŒYè½´æ—‹è½¬
            newCard.mesh.rotation.x = 0; // ä¸è¿›è¡ŒXè½´æ—‹è½¬
            
            // è®¾ç½®åˆå§‹é€æ˜åº¦ä¸º0ï¼ˆæ·¡å…¥æ•ˆæœï¼‰
            newCard.mesh.material.forEach(mat => {
                if (mat.transparent === undefined) {
                    mat.transparent = true;
                }
                mat.opacity = 0;
            });
            
            // æ·»åŠ åˆ°åœºæ™¯å’Œæ•°ç»„
            this.scene.add(newCard.mesh);
            this.cardMeshes.push({
                mesh: newCard.mesh,
                data: { ...newCardData, isReversed },
                originalPosition: new THREE.Vector3(rightX, rightY, cardCount * 0.001),
                originalRotation: new THREE.Euler(0, 0, rightAngle - Math.PI / 2),
                index: cardCount - 1,
                targetPosition: new THREE.Vector3(rightX, rightY, cardCount * 0.001),
                targetRotation: new THREE.Euler(0, 0, rightAngle - Math.PI / 2),
                isTransitioning: true,
                isFadingIn: true,
                opacity: 0.0,
                isSelected: false
            });
            
            // æ›´æ–°å…¶ä»–å¡ç‰Œçš„ä½ç½®
            for (let i = 0; i < this.cardMeshes.length - 1; i++) {
                const card = this.cardMeshes[i];
                if (card.isSelected) continue; // è·³è¿‡å·²é€‰ä¸­çš„å¡ç‰Œ
                
                card.index = i;
                
                // é‡æ–°è®¡ç®—æ‰‡å½¢ä½ç½®
                const angle = startAngle + angleStep * i;
                const x = centerX + radius * Math.cos(angle);
                const y = pivotY + radius * Math.sin(angle);
                
                card.originalPosition = new THREE.Vector3(x, y, i * 0.001);
                card.originalRotation = new THREE.Euler(0, 0, angle - Math.PI / 2);
                card.targetPosition = new THREE.Vector3(x, y, i * 0.001);
                card.targetRotation = new THREE.Euler(0, 0, angle - Math.PI / 2);
                card.isTransitioning = true;
            }
            
            // å»¶è¿Ÿç§»é™¤æ—§å¡ç‰Œ
            setTimeout(() => {
                this.scene.remove(firstCard.mesh);
            }, 500);
            
        } else if (direction === 'right') {
            // å‘å³è½®æ¢ï¼šæœ€åä¸€å¼ å¡ç‰Œç§»åˆ°æœ€å‰ï¼Œå¹¶æ›¿æ¢ä¸ºæ–°å¡ç‰Œ
            const lastCard = this.cardMeshes.pop();
            
            // åˆ›å»ºç²’å­æ•ˆæœ
            this.createRotationParticles(lastCard.mesh.position, 'right', isSuperRotation);
            
            // åœ¨æ»‘åŠ¨è¿‡ç¨‹ä¸­åˆ›å»ºé¢å¤–çš„ç²’å­è½¨è¿¹
            this.createSwipeParticles(lastCard.mesh.position, 'right', isSuperRotation);
            
            // å°†æœ€åä¸€å¼ å¡ç‰Œç§»å‡ºå±å¹•å³ä¾§ï¼Œå¹¶è®¾ç½®æ·¡å‡ºæ•ˆæœ
            const rightAngle = endAngle + 0.1; // è¶…å‡ºæ‰‡å½¢èŒƒå›´
            const rightX = centerX + radius * Math.cos(rightAngle);
            const rightY = pivotY + radius * Math.sin(rightAngle);
            lastCard.targetPosition = new THREE.Vector3(rightX, rightY, lastCard.mesh.position.z);
            lastCard.targetRotation = new THREE.Euler(0, 0, rightAngle - Math.PI / 2); // Zè½´æ—‹è½¬å‚ç›´äºåœ†åŠå¾„
            lastCard.isTransitioning = true;
            lastCard.isFadingOut = true;
            lastCard.opacity = 1.0;
            
            // åˆ›å»ºæ–°å¡ç‰Œï¼ˆç‰Œé¢æœä¸‹ï¼‰
            const newCardData = this.getCardFromPool();
            const isReversed = Math.random() < 0.5;
            const newCard = this.createCardMesh(newCardData, isReversed, true);
            
            // è®¾ç½®æ–°å¡ç‰Œä½ç½®ï¼ˆä»å·¦ä¾§è¿›å…¥ï¼‰ï¼Œå¹¶è®¾ç½®æ·¡å…¥æ•ˆæœ
            const leftAngle = startAngle - 0.1; // è¶…å‡ºæ‰‡å½¢èŒƒå›´
            const leftX = centerX + radius * Math.cos(leftAngle);
            const leftY = pivotY + radius * Math.sin(leftAngle);
            const newPosition = new THREE.Vector3(leftX, leftY, 0);
            newCard.mesh.position.copy(newPosition);
            newCard.mesh.rotation.z = leftAngle - Math.PI / 2; // Zè½´æ—‹è½¬å‚ç›´äºåœ†åŠå¾„
            newCard.mesh.rotation.y = 0; // ä¸è¿›è¡ŒYè½´æ—‹è½¬
            newCard.mesh.rotation.x = 0; // ä¸è¿›è¡ŒXè½´æ—‹è½¬
            
            // è®¾ç½®åˆå§‹é€æ˜åº¦ä¸º0ï¼ˆæ·¡å…¥æ•ˆæœï¼‰
            newCard.mesh.material.forEach(mat => {
                if (mat.transparent === undefined) {
                    mat.transparent = true;
                }
                mat.opacity = 0;
            });
            
            // æ·»åŠ åˆ°åœºæ™¯å’Œæ•°ç»„
            this.scene.add(newCard.mesh);
            this.cardMeshes.unshift({
                mesh: newCard.mesh,
                data: { ...newCardData, isReversed },
                originalPosition: new THREE.Vector3(leftX, leftY, 0),
                originalRotation: new THREE.Euler(0, 0, leftAngle - Math.PI / 2),
                index: 0,
                targetPosition: new THREE.Vector3(leftX, leftY, 0),
                targetRotation: new THREE.Euler(0, 0, leftAngle - Math.PI / 2),
                isTransitioning: true,
                isFadingIn: true,
                opacity: 0.0,
                isSelected: false
            });
            
            // æ›´æ–°å…¶ä»–å¡ç‰Œçš„ä½ç½®
            for (let i = 1; i < this.cardMeshes.length; i++) {
                const card = this.cardMeshes[i];
                if (card.isSelected) continue; // è·³è¿‡å·²é€‰ä¸­çš„å¡ç‰Œ
                
                card.index = i;
                
                // é‡æ–°è®¡ç®—æ‰‡å½¢ä½ç½®
                const angle = startAngle + angleStep * i;
                const x = centerX + radius * Math.cos(angle);
                const y = pivotY + radius * Math.sin(angle);
                
                card.originalPosition = new THREE.Vector3(x, y, i * 0.001);
                card.originalRotation = new THREE.Euler(0, 0, angle - Math.PI / 2);
                card.targetPosition = new THREE.Vector3(x, y, i * 0.001);
                card.targetRotation = new THREE.Euler(0, 0, angle - Math.PI / 2);
                card.isTransitioning = true;
            }
            
            // å»¶è¿Ÿç§»é™¤æ—§å¡ç‰Œ
            setTimeout(() => {
                this.scene.remove(lastCard.mesh);
            }, 500);
        }
        
        // è°ƒæ•´é€‰ä¸­çš„å¡ç‰Œç´¢å¼•
        if (this.selectedCardIndex >= 0 && this.selectedCardIndex < this.cardMeshes.length) {
            // ä¿æŒé€‰ä¸­ä¸­é—´çš„å¡ç‰Œ
            this.selectedCardIndex = Math.floor(cardCount / 2);
        }
        
        // å¦‚æœæ˜¯è¶…çº§è½®è½¬æ¨¡å¼ï¼Œæ‰§è¡Œå¤šæ¬¡è½®è½¬
        if (isSuperRotation && rotationCount > 1) {
            this.performMultipleRotations(direction, rotationCount - 1);
        }
    }
    
    // æ‰§è¡Œå¤šæ¬¡è½®è½¬ï¼ˆç”¨äºè¶…çº§è½®è½¬æ¨¡å¼ï¼‰
    performMultipleRotations(direction, remainingRotations) {
        if (remainingRotations <= 0) return;
        
        // å»¶è¿Ÿæ‰§è¡Œä¸‹ä¸€æ¬¡è½®è½¬
        setTimeout(() => {
            this.rotateCards(direction, false); // æ™®é€šè½®è½¬æ¨¡å¼
            this.performMultipleRotations(direction, remainingRotations - 1);
        }, 100); // æ¯æ¬¡è½®è½¬é—´éš”100æ¯«ç§’
    }
    
    // åˆ›å»ºè½®æ¢æ—¶çš„ç²’å­æ•ˆæœ
    createRotationParticles(position, direction, isSuperRotation = false) {
        const particleCount = isSuperRotation ? 800 : 300; // è¶…çº§è½®è½¬æ¨¡å¼ä½¿ç”¨æ›´å¤šç²’å­
        const geom = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const velocityArray = new Float32Array(particleCount * 3);
        const colorArray = new Float32Array(particleCount * 3);
        
        // æ ¹æ®æ–¹å‘è®¾ç½®ç²’å­é¢œè‰²å’Œè¿åŠ¨æ–¹å‘
        const baseColor = direction === 'left' ?
            new THREE.Color(0xd4af37) : // é‡‘è‰²
            new THREE.Color(0x9370db);  // ç´«è‰²
        
        for(let i = 0; i < particleCount; i++) {
            // åœ¨å¡ç‰Œä½ç½®å‘¨å›´éšæœºåˆ†å¸ƒ
            posArray[i*3] = position.x + (Math.random() - 0.5) * 2;
            posArray[i*3+1] = position.y + (Math.random() - 0.5) * 3.5;
            posArray[i*3+2] = position.z + (Math.random() - 0.5) * 1;
            
            // è®¾ç½®é€Ÿåº¦æ–¹å‘
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 0.1 + 0.05;
            const horizontalSpeed = direction === 'left' ? -Math.abs(speed) : Math.abs(speed);
            
            velocityArray[i*3] = horizontalSpeed + Math.cos(angle) * 0.05; // Xæ–¹å‘
            velocityArray[i*3+1] = Math.sin(angle) * 0.05 + Math.random() * 0.05; // Yæ–¹å‘
            velocityArray[i*3+2] = (Math.random() - 0.5) * 0.05; // Zæ–¹å‘
            
            // è®¾ç½®é¢œè‰²ï¼ˆå¸¦æœ‰ä¸€äº›éšæœºå˜åŒ–ï¼‰
            const colorVariation = new THREE.Color(
                baseColor.r + (Math.random() - 0.5) * 0.2,
                baseColor.g + (Math.random() - 0.5) * 0.2,
                baseColor.b + (Math.random() - 0.5) * 0.2
            );
            colorArray[i*3] = colorVariation.r;
            colorArray[i*3+1] = colorVariation.g;
            colorArray[i*3+2] = colorVariation.b;
        }
        
        geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geom.setAttribute('velocity', new THREE.BufferAttribute(velocityArray, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        
        const material = new THREE.PointsMaterial({
            size: isSuperRotation ? 0.08 : 0.05, // è¶…çº§è½®è½¬æ¨¡å¼ä½¿ç”¨æ›´å¤§çš„ç²’å­
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geom, material);
        this.scene.add(particles);
        
        // æ·»åŠ åˆ°ç²’å­æ•°ç»„
        this.rotationParticles.push({
            mesh: particles,
            life: 1.0
        });
    }
    
    // æ›´æ–°è½®æ¢ç²’å­æ•ˆæœ
    updateRotationParticles() {
        for (let i = this.rotationParticles.length - 1; i >= 0; i--) {
            const particleSystem = this.rotationParticles[i];
            const positions = particleSystem.mesh.geometry.attributes.position.array;
            const velocities = particleSystem.mesh.geometry.attributes.velocity.array;
            
            // æ›´æ–°ç²’å­ä½ç½®
            for(let j = 0; j < positions.length / 3; j++) {
                positions[j*3] += velocities[j*3];     // X
                positions[j*3+1] += velocities[j*3+1]; // Y
                positions[j*3+2] += velocities[j*3+2]; // Z
                
                // æ·»åŠ ä¸€äº›éšæœºè¿åŠ¨
                velocities[j*3] += (Math.random() - 0.5) * 0.002;
                velocities[j*3+1] += Math.random() * 0.001; // è½»å¾®ä¸Šå‡
            }
            
            particleSystem.mesh.geometry.attributes.position.needsUpdate = true;
            
            // æ›´æ–°ç”Ÿå‘½å€¼å’Œé€æ˜åº¦
            particleSystem.life -= 0.02;
            particleSystem.mesh.material.opacity = particleSystem.life * 0.8;
            
            // ç§»é™¤æ­»äº¡çš„ç²’å­ç³»ç»Ÿ
            if (particleSystem.life <= 0) {
                this.scene.remove(particleSystem.mesh);
                this.rotationParticles.splice(i, 1);
            }
        }
    }
    
    // åˆ›å»ºæ»‘åŠ¨è¿‡ç¨‹ä¸­çš„ç²’å­è½¨è¿¹æ•ˆæœ
    createSwipeParticles(position, direction, isSuperRotation = false) {
        const particleCount = isSuperRotation ? 400 : 150; // è¶…çº§è½®è½¬æ¨¡å¼ä½¿ç”¨æ›´å¤šç²’å­
        const geom = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const velocityArray = new Float32Array(particleCount * 3);
        const colorArray = new Float32Array(particleCount * 3);
        
        // æ ¹æ®æ–¹å‘è®¾ç½®ç²’å­é¢œè‰²
        const baseColor = direction === 'left' ?
            new THREE.Color(0xffd700) : // é‡‘è‰²
            new THREE.Color(0x9370db);  // ç´«è‰²
        
        for(let i = 0; i < particleCount; i++) {
            // åœ¨å¡ç‰Œä½ç½®å‘¨å›´éšæœºåˆ†å¸ƒ
            posArray[i*3] = position.x + (Math.random() - 0.5) * 1.5;
            posArray[i*3+1] = position.y + (Math.random() - 0.5) * 2;
            posArray[i*3+2] = position.z + (Math.random() - 0.5) * 0.5;
            
            // è®¾ç½®é€Ÿåº¦æ–¹å‘ï¼Œå½¢æˆè½¨è¿¹æ•ˆæœ
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 0.08 + 0.02;
            const horizontalSpeed = direction === 'left' ? -Math.abs(speed) : Math.abs(speed);
            
            velocityArray[i*3] = horizontalSpeed + Math.cos(angle) * 0.03; // Xæ–¹å‘
            velocityArray[i*3+1] = Math.sin(angle) * 0.03 + Math.random() * 0.02; // Yæ–¹å‘
            velocityArray[i*3+2] = (Math.random() - 0.5) * 0.03; // Zæ–¹å‘
            
            // è®¾ç½®é¢œè‰²ï¼ˆå¸¦æœ‰ä¸€äº›éšæœºå˜åŒ–ï¼‰
            const colorVariation = new THREE.Color(
                baseColor.r + (Math.random() - 0.5) * 0.3,
                baseColor.g + (Math.random() - 0.5) * 0.3,
                baseColor.b + (Math.random() - 0.5) * 0.3
            );
            colorArray[i*3] = colorVariation.r;
            colorArray[i*3+1] = colorVariation.g;
            colorArray[i*3+2] = colorVariation.b;
        }
        
        geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geom.setAttribute('velocity', new THREE.BufferAttribute(velocityArray, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        
        const material = new THREE.PointsMaterial({
            size: isSuperRotation ? 0.15 : 0.10, // è¶…çº§è½®è½¬æ¨¡å¼ä½¿ç”¨æ›´å¤§çš„ç²’å­
            transparent: true,
            opacity: 0.7,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geom, material);
        this.scene.add(particles);
        
        // æ·»åŠ åˆ°æ»‘åŠ¨ç²’å­æ•°ç»„
        if (!this.swipeParticles) {
            this.swipeParticles = [];
        }
        this.swipeParticles.push({
            mesh: particles,
            life: 1.0
        });
    }
    
    // æ›´æ–°æ»‘åŠ¨ç²’å­æ•ˆæœ
    updateSwipeParticles() {
        if (!this.swipeParticles) return;
        
        for (let i = this.swipeParticles.length - 1; i >= 0; i--) {
            const particleSystem = this.swipeParticles[i];
            const positions = particleSystem.mesh.geometry.attributes.position.array;
            const velocities = particleSystem.mesh.geometry.attributes.velocity.array;
            
            // æ›´æ–°ç²’å­ä½ç½®
            for(let j = 0; j < positions.length / 3; j++) {
                positions[j*3] += velocities[j*3];     // X
                positions[j*3+1] += velocities[j*3+1]; // Y
                positions[j*3+2] += velocities[j*3+2]; // Z
                
                // æ·»åŠ ä¸€äº›éšæœºè¿åŠ¨
                velocities[j*3] += (Math.random() - 0.5) * 0.001;
                velocities[j*3+1] += Math.random() * 0.001; // è½»å¾®ä¸Šå‡
            }
            
            particleSystem.mesh.geometry.attributes.position.needsUpdate = true;
            
            // æ›´æ–°ç”Ÿå‘½å€¼å’Œé€æ˜åº¦ï¼Œå‡æ…¢æ·¡å‡ºé€Ÿåº¦
            particleSystem.life -= 0.004; // è¿›ä¸€æ­¥å‡æ…¢æ·¡å‡ºé€Ÿåº¦
            particleSystem.mesh.material.opacity = particleSystem.life * 0.7;
            
            // ç§»é™¤æ­»äº¡çš„ç²’å­ç³»ç»Ÿ
            if (particleSystem.life <= 0) {
                this.scene.remove(particleSystem.mesh);
                this.swipeParticles.splice(i, 1);
            }
        }
    }
    
    // åˆ›å»ºå•ä¸ªå¡ç‰Œç½‘æ ¼
    createCardMesh(data, isReversed, faceDown = false) {
        // å‡ ä½•ä½“
        const geometry = new THREE.BoxGeometry(2, 3.5, 0.05);
        
        // æè´¨åŠ è½½
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin("anonymous"); // è§£å†³è·¨åŸŸ
        
        // åˆ›å»ºå¡ç‰ŒèƒŒé¢çº¹ç†ï¼ˆå¡”ç½—ç‰ŒèƒŒé¢å›¾æ¡ˆï¼‰
        const backCanvas = document.createElement('canvas');
        backCanvas.width = 256;
        backCanvas.height = 448;
        const ctx = backCanvas.getContext('2d');
        
        // ç»˜åˆ¶å¡”ç½—ç‰ŒèƒŒé¢å›¾æ¡ˆ
        const gradient = ctx.createRadialGradient(128, 224, 0, 128, 224, 120);
        gradient.addColorStop(0, '#2a2a3e');
        gradient.addColorStop(0.5, '#1a1a2e');
        gradient.addColorStop(1, '#0f0f15');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 448);
        
        // æ·»åŠ è£…é¥°è¾¹æ¡†
        ctx.strokeStyle = '#d4af37';
        ctx.lineWidth = 8;
        ctx.strokeRect(10, 10, 236, 428);
        
        // æ·»åŠ ä¸­å¿ƒå›¾æ¡ˆ
        ctx.beginPath();
        ctx.arc(128, 224, 60, 0, Math.PI * 2);
        ctx.strokeStyle = '#d4af37';
        ctx.lineWidth = 4;
        ctx.stroke();
        
        // æ·»åŠ æ˜Ÿå½¢å›¾æ¡ˆ
        this.drawStar(ctx, 128, 224, 5, 30, 15);
        ctx.fillStyle = '#d4af37';
        ctx.fill();
        
        const backTexture = new THREE.CanvasTexture(backCanvas);
        const backMat = new THREE.MeshStandardMaterial({ map: backTexture, roughness: 0.6 });
        
        // æ­£é¢çº¹ç†
        const frontUrl = `${CONFIG.baseUrl}${data.id}.jpg`;
        const frontTex = loader.load(frontUrl);
        const frontMat = new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4 });
        const sideMat = new THREE.MeshStandardMaterial({ color: 0xccaa00 }); // é‡‘è¾¹

        // æè´¨æ•°ç»„: Right, Left, Top, Bottom, Front, Back
        // å¦‚æœç‰Œé¢æœä¸‹ï¼Œå°†èƒŒé¢æè´¨æ”¾åœ¨å‰é¢
        const materials = faceDown ?
            [sideMat, sideMat, sideMat, sideMat, backMat, frontMat] :
            [sideMat, sideMat, sideMat, sideMat, frontMat, backMat];

        const mesh = new THREE.Mesh(geometry, materials);
        mesh.castShadow = true;
        
        // å¦‚æœç‰Œé¢æœä¸‹ï¼Œæ—‹è½¬180åº¦æ˜¾ç¤ºèƒŒé¢
        if (faceDown) {
            mesh.rotation.y = Math.PI;
        }
        
        // é€†ä½æ—‹è½¬
        if (isReversed) {
            mesh.rotation.z = Math.PI;
        }
        
        return { mesh, data };
    }
    
    // ç»˜åˆ¶æ˜Ÿå½¢å›¾æ¡ˆ
    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;
        
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;
            
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
    }
    
    // æ›´æ–°å¡ç‰Œé€‰æ‹©ï¼ˆåŸºäºé¼ æ ‡/æ‰‹åŠ¿ä½ç½®ï¼Œé€‚åº”æ‰‡å½¢å¸ƒå±€ï¼‰
    updateCardSelection() {
        if (!this.cursor.active || this.cardMeshes.length === 0) return;
        
        // å°†å…‰æ ‡ä½ç½®è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
        const worldX = this.cursor.x * 10; // æ‰©å¤§èŒƒå›´ä»¥åŒ¹é…æ‰‡å½¢
        const worldY = this.cursor.y * 5;
        
        // æ‰¾åˆ°æœ€è¿‘çš„å¡ç‰Œ
        let closestCard = null;
        let closestDistance = Infinity;
        let closestIndex = -1;
        
        this.cardMeshes.forEach((card, index) => {
            if (card.isSelected) return; // è·³è¿‡å·²é€‰ä¸­çš„å¡ç‰Œ
            
            // è®¡ç®—å…‰æ ‡åˆ°å¡ç‰Œçš„è·ç¦»
            const distance = Math.sqrt(
                Math.pow(worldX - card.mesh.position.x, 2) +
                Math.pow(worldY - card.mesh.position.y, 2)
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestCard = card;
                closestIndex = index;
            }
        });
        
        // å¦‚æœæ‰¾åˆ°äº†æœ€è¿‘çš„å¡ç‰Œä¸”è·ç¦»åœ¨åˆç†èŒƒå›´å†…ï¼Œæ›´æ–°é€‰ä¸­çŠ¶æ€
        if (closestCard && closestDistance < 2.0) {
            if (closestIndex !== this.selectedCardIndex) {
                this.selectedCardIndex = closestIndex;
                this.updateCardHighlight();
            }
        }
    }
    
    // æ›´æ–°å¡ç‰Œé«˜äº®æ•ˆæœï¼ˆé€‚åº”æ‰‡å½¢å¸ƒå±€ï¼‰
    updateCardHighlight() {
        this.cardMeshes.forEach((card, index) => {
            // å¤„ç†è¿‡æ¸¡åŠ¨ç”»
            if (card.isTransitioning) {
                card.mesh.position.lerp(card.targetPosition, this.cardTransitionSpeed);
                
                // å¤„ç†æ—‹è½¬è¿‡æ¸¡
                if (card.targetRotation) {
                    card.mesh.rotation.x = THREE.MathUtils.lerp(
                        card.mesh.rotation.x,
                        card.targetRotation.x,
                        this.cardTransitionSpeed
                    );
                    card.mesh.rotation.y = THREE.MathUtils.lerp(
                        card.mesh.rotation.y,
                        card.targetRotation.y,
                        this.cardTransitionSpeed
                    );
                    card.mesh.rotation.z = THREE.MathUtils.lerp(
                        card.mesh.rotation.z,
                        card.targetRotation.z,
                        this.cardTransitionSpeed
                    );
                }
                
                // å¤„ç†æ·¡å…¥æ·¡å‡ºæ•ˆæœ
                if (card.isFadingIn) {
                    card.opacity = Math.min(1.0, card.opacity + 0.05);
                    card.mesh.material.forEach(mat => {
                        mat.opacity = card.opacity;
                    });
                    
                    if (card.opacity >= 1.0) {
                        card.isFadingIn = false;
                    }
                } else if (card.isFadingOut) {
                    card.opacity = Math.max(0.0, card.opacity - 0.05);
                    card.mesh.material.forEach(mat => {
                        mat.opacity = card.opacity;
                    });
                }
                
                // æ£€æŸ¥æ˜¯å¦æ¥è¿‘ç›®æ ‡ä½ç½®
                const distance = card.mesh.position.distanceTo(card.targetPosition);
                if (distance < 0.1) {
                    card.mesh.position.copy(card.targetPosition);
                    if (card.targetRotation) {
                        card.mesh.rotation.copy(card.targetRotation);
                    }
                    card.isTransitioning = false;
                }
            }
            
            // åº”ç”¨é«˜äº®æ•ˆæœï¼ˆä»…å¯¹æœªé€‰ä¸­çš„å¡ç‰Œï¼‰
            if (!card.isSelected) {
                if (index === this.selectedCardIndex && !card.isTransitioning) {
                    // é€‰ä¸­çš„å¡ç‰Œä¸Šæµ®å¹¶ç¨å¾®æ”¾å¤§
                    const highlightPosition = new THREE.Vector3(
                        card.originalPosition.x,
                        card.originalPosition.y + 0.5,
                        card.originalPosition.z + 0.5
                    );
                    card.mesh.position.lerp(highlightPosition, 0.1);
                    card.mesh.scale.lerp(new THREE.Vector3(1.1, 1.1, 1.1), 0.1);
                } else if (!card.isTransitioning) {
                    // æœªé€‰ä¸­çš„å¡ç‰Œå›åˆ°åŸä½ç½®
                    card.mesh.position.lerp(card.originalPosition, 0.1);
                    card.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }
            }
        });
        
        // æ›´æ–°è½®æ¢ç²’å­æ•ˆæœ
        this.updateRotationParticles();
    }
    
    // é€‰æ‹©å¡ç‰Œï¼ˆæŠ“å–åŠŸèƒ½ï¼‰
    selectCard(index) {
        if (index < 0 || index >= this.cardMeshes.length) return;
        
        const selectedCard = this.cardMeshes[index];
        
        // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²ç»è¢«é€‰ä¸­
        if (selectedCard.isSelected) return;
        
        this.currentCardData = selectedCard.data;
        
        // å…ˆæ ‡è®°å¡ç‰Œä¸ºå·²é€‰ä¸­
        selectedCard.isSelected = true;
        
        // è®¡ç®—å½“å‰å·²é€‰ä¸­çš„å¡ç‰Œæ•°é‡ï¼ˆåŒ…æ‹¬åˆšåˆšé€‰ä¸­çš„è¿™å¼ ï¼‰
        const selectedCount = this.cardMeshes.filter(card => card.isSelected).length;
        
        // å°†å¡ç‰Œæ˜¾ç¤ºåœ¨å¯¹åº”çš„å±•ç¤ºæ¡†ä¸­
        this.displayCardInSlot(selectedCard.data, selectedCount - 1);
        
        // æ˜¾ç¤ºå¡ç‰Œå¼¹å‡ºçª—å£
        this.cardPopup.show(selectedCard.data);
        
        // ç¿»è½¬å¡ç‰Œæ˜¾ç¤ºæ­£é¢
        if (selectedCard.isFaceDown) {
            // åˆ›å»ºç¿»è½¬åŠ¨ç”»
            this.flipCard(selectedCard);
        }
        
        // ä½¿å¡ç‰Œæ¶ˆå¤±ï¼ˆåˆ›å»ºæ¶ˆå¤±åŠ¨ç”»ï¼‰
        this.makeCardDisappear(selectedCard);
        
        // å¦‚æœå·²é€‰ä¸­3å¼ å¡ç‰Œï¼Œè§¦å‘ç‰¹æ®Šæ•ˆæœå¹¶é‡æ–°ç”Ÿæˆç‰Œé˜µ
        if (selectedCount >= 3) {
            // å»¶è¿Ÿåˆ›å»ºç²’å­æ•ˆæœï¼Œç­‰å¾…æ‰€æœ‰å¡ç‰Œç¿»è½¬åŠ¨ç”»å®Œæˆ
            setTimeout(() => {
                this.triggerAshEffect();
            }, 1000);
            
            // é‡æ–°ç”Ÿæˆå¡ç‰Œè¡Œ
            setTimeout(() => this.spawnCardRow(), 3500);
        }
    }
    
    // ä½¿å¡ç‰Œæ¶ˆå¤±
    makeCardDisappear(card) {
        const duration = 800; // æ¶ˆå¤±åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        const startTime = Date.now();
        const startScale = card.mesh.scale.x;
        const startOpacity = card.mesh.material[0].opacity;
        
        const disappearAnimation = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
            const easeProgress = this.easeInOutCubic(progress);
            
            // ç¼©å°å¹¶æ·¡å‡º
            const newScale = startScale * (1 - easeProgress);
            card.mesh.scale.set(newScale, newScale, newScale);
            
            // æ›´æ–°é€æ˜åº¦
            const newOpacity = startOpacity * (1 - easeProgress);
            card.mesh.material.forEach(mat => {
                mat.opacity = newOpacity;
            });
            
            // è½»å¾®ä¸Šå‡
            card.mesh.position.y += 0.02;
            
            if (progress < 1) {
                requestAnimationFrame(disappearAnimation);
            } else {
                // åŠ¨ç”»å®Œæˆåï¼Œä»åœºæ™¯ä¸­ç§»é™¤å¡ç‰Œ
                this.scene.remove(card.mesh);
            }
        };
        
        disappearAnimation();
    }
    
    // å°†å¡ç‰Œæ˜¾ç¤ºåœ¨å±•ç¤ºæ¡†ä¸­
    displayCardInSlot(cardData, slotIndex) {
        // ç¡®ä¿æ§½ä½ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
        if (slotIndex < 0 || slotIndex >= this.cardSlots.length) return;
        
        // æ£€æŸ¥ç›®æ ‡æ§½ä½æ˜¯å¦å·²è¢«å ç”¨
        if (this.cardSlots[slotIndex].classList.contains('occupied')) {
            // å¦‚æœå·²è¢«å ç”¨ï¼ŒæŸ¥æ‰¾ç¬¬ä¸€ä¸ªç©ºçš„å±•ç¤ºæ¡†
            let foundSlot = false;
            for (let i = 0; i < this.cardSlots.length; i++) {
                if (!this.cardSlots[i].classList.contains('occupied')) {
                    slotIndex = i;
                    foundSlot = true;
                    break;
                }
            }
            // å¦‚æœæ‰€æœ‰å±•ç¤ºæ¡†éƒ½è¢«å ç”¨ï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            if (!foundSlot) return;
        }
        
        const slot = this.cardSlots[slotIndex];
        const slotInner = slot.querySelector('.card-slot-inner');
        
        // æ¸…ç©ºæ§½å†…å†…å®¹
        slotInner.innerHTML = '';
        
        // åˆ›å»ºå¡ç‰Œå›¾ç‰‡å…ƒç´ 
        const cardImage = document.createElement('img');
        cardImage.src = `${CONFIG.baseUrl}${cardData.id}.jpg`;
        cardImage.alt = cardData.name;
        cardImage.className = 'displayed-card';
        
        // æ·»åŠ å¡ç‰Œä¿¡æ¯
        const cardInfo = document.createElement('div');
        cardInfo.style.position = 'absolute';
        cardInfo.style.bottom = '3px';
        cardInfo.style.left = '0';
        cardInfo.style.right = '0';
        cardInfo.style.textAlign = 'center';
        cardInfo.style.color = '#d4af37';
        cardInfo.style.fontSize = '10px';
        cardInfo.style.fontWeight = 'bold';
        cardInfo.style.textShadow = '0 0 3px rgba(0, 0, 0, 0.8)';
        cardInfo.style.background = 'rgba(0, 0, 0, 0.6)';
        cardInfo.style.padding = '2px';
        cardInfo.style.borderRadius = '3px';
        cardInfo.style.whiteSpace = 'nowrap';
        cardInfo.style.overflow = 'hidden';
        cardInfo.style.textOverflow = 'ellipsis';
        cardInfo.textContent = cardData.name;
        
        // æ·»åŠ åˆ°æ§½å†…
        slotInner.appendChild(cardImage);
        slotInner.appendChild(cardInfo);
        
        // æ ‡è®°æ§½ä¸ºå·²å ç”¨
        slot.classList.add('occupied');
        
        // æ›´æ–°æ ‡ç­¾
        const label = slot.querySelector('.card-slot-label');
        label.textContent = cardData.isReversed ? `${cardData.name} (é€†)` : cardData.name;
        
        // ä¿å­˜å¡ç‰Œæ•°æ®
        this.displayedCards[slotIndex] = cardData;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œç‚¹å‡»å±•ç¤ºæ¡†ä¸­çš„å¡ç‰Œå¯ä»¥æŸ¥çœ‹è¯¦æƒ…
        slotInner.style.cursor = 'pointer';
        slotInner.onclick = () => {
            this.cardPopup.show(cardData);
        };
    }
    
    // æ¸…ç©ºæŒ‡å®šçš„å¡ç‰Œå±•ç¤ºæ¡†
    clearCardSlot(slotIndex) {
        if (slotIndex < 0 || slotIndex >= this.cardSlots.length) return;
        
        const slot = this.cardSlots[slotIndex];
        const slotInner = slot.querySelector('.card-slot-inner');
        
        // æ¸…ç©ºå†…å®¹
        slotInner.innerHTML = '';
        
        // ç§»é™¤å ç”¨çŠ¶æ€
        slot.classList.remove('occupied');
        
        // é‡ç½®æ ‡ç­¾
        const label = slot.querySelector('.card-slot-label');
        label.textContent = `ä½ç½® ${slotIndex + 1}`;
        
        // æ¸…é™¤å¡ç‰Œæ•°æ®
        this.displayedCards[slotIndex] = null;
        
        // ç§»é™¤ç‚¹å‡»äº‹ä»¶
        slotInner.style.cursor = 'default';
        slotInner.onclick = null;
    }
    
    // æ¸…ç©ºæ‰€æœ‰å¡ç‰Œå±•ç¤ºæ¡†
    clearAllCardSlots() {
        for (let i = 0; i < this.cardSlots.length; i++) {
            this.clearCardSlot(i);
        }
    }
    
    // å°†é€‰ä¸­çš„å¡ç‰Œç§»åŠ¨åˆ°ç„¦ç‚¹åŒºåŸŸï¼ˆåœ†å¿ƒä¸Šæ–¹ã€å¼§çº¿åœ†æ‹±çš„å†…éƒ¨ä¸­å¿ƒï¼‰
    moveCardToForeground(card) {
        // è®¡ç®—å·²é€‰ä¸­çš„å¡ç‰Œæ•°é‡
        const selectedCards = this.cardMeshes.filter(c => c.isSelected);
        const selectedIndex = selectedCards.length - 1; // å½“å‰å¡ç‰Œçš„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
        
        // ç„¦ç‚¹åŒºåŸŸå‚æ•°ï¼šåœ†å¿ƒä¸Šæ–¹ã€å¼§çº¿åœ†æ‹±çš„å†…éƒ¨ä¸­å¿ƒä½ç½®
        const focusY = -2; // åœ†å¿ƒä¸Šæ–¹ä½ç½®
        const focusZ = 2; // ç¨å¾®å‘å‰ï¼Œæ›´é è¿‘æ‘„åƒæœº
        const cardSpacing = 2.5; // å¡ç‰Œé—´è·
        
        // è®¡ç®—å¡ç‰Œåœ¨ç„¦ç‚¹åŒºåŸŸä¸­çš„ä½ç½®ï¼ˆæ°´å¹³æ’åˆ—ï¼‰
        const totalWidth = (selectedCards.length - 1) * cardSpacing;
        const startX = -totalWidth / 2;
        const targetX = startX + selectedIndex * cardSpacing;
        
        // è®¾ç½®ç›®æ ‡ä½ç½®å’Œæ—‹è½¬
        card.targetPosition = new THREE.Vector3(targetX, focusY, focusZ);
        card.targetRotation = new THREE.Euler(0, 0, 0); // æ­£é¢æœä¸Šï¼Œä¸å€¾æ–œ
        card.isTransitioning = true;
        
        // å¦‚æœå¡ç‰Œæ˜¯èƒŒé¢æœä¸Šï¼Œæ·»åŠ ç¿»è½¬åŠ¨ç”»
        if (card.isFaceDown) {
            this.flipCard(card);
        }
    }
    
    // ç¿»è½¬å¡ç‰ŒåŠ¨ç”»
    flipCard(card) {
        const startRotation = card.mesh.rotation.y;
        const endRotation = startRotation + Math.PI;
        const duration = 500; // ç¿»è½¬åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        const startTime = Date.now();
        
        const flipAnimation = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
            const easeProgress = this.easeInOutCubic(progress);
            
            // æ›´æ–°æ—‹è½¬
            card.mesh.rotation.y = startRotation + (endRotation - startRotation) * easeProgress;
            
            if (progress < 1) {
                requestAnimationFrame(flipAnimation);
            }
        };
        
        flipAnimation();
    }
    
    // ç¼“åŠ¨å‡½æ•°
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    // ç”Ÿæˆä¸€å¼ æ–°ç‰Œï¼ˆä¿ç•™åŸæ–¹æ³•ä»¥å…¼å®¹ï¼‰
    spawnNewCard() {
        this.spawnCardRow();
    }

    // è§¦å‘ç°çƒ¬ç‰¹æ•ˆå¹¶è®°å½•ï¼ˆå¤„ç†å¤šå¼ é€‰ä¸­çš„å¡ç‰Œï¼‰
    triggerAshEffect() {
        if (this.state === 'ASH_PHASE') return;
        this.state = 'ASH_PHASE';
        
        // è·å–æ‰€æœ‰é€‰ä¸­çš„å¡ç‰Œ
        const selectedCards = this.cardMeshes.filter(card => card.isSelected);
        
        // 1. è®°å½•å†å²ï¼ˆä¸ºæ¯å¼ é€‰ä¸­çš„å¡ç‰Œï¼‰
        selectedCards.forEach((card, index) => {
            const historyList = document.getElementById('history-list');
            const item = document.createElement('div');
            item.className = 'history-item';
            
            // è·å–å½“å‰æ—¶é—´
            const now = new Date();
            const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            // ç¡®å®šå¡ç‰Œä½ç½®ï¼ˆåŸºäºå±•ç¤ºæ¡†ä½ç½®ï¼‰
            const positionNames = ['è¿‡å»', 'ç°åœ¨', 'æœªæ¥'];
            const positionName = positionNames[index] || `ä½ç½® ${index + 1}`;
            
            // åˆ›å»ºè¯¦ç»†çš„å¡ç‰Œå†å²è®°å½•
            item.innerHTML = `
                <div class="history-card-container">
                    <img src="${CONFIG.baseUrl}${card.data.id}.jpg" alt="${card.data.name}" class="history-card-image">
                    <div class="history-card-info">
                        <div class="history-card-name">${card.data.name}</div>
                        <div class="history-card-position">${positionName}</div>
                        <div class="history-card-meaning ${card.data.isReversed ? 'history-rev' : 'history-up'}">
                            ${card.data.isReversed ? 'é€†ä½: ' : 'æ­£ä½: '}${card.data.isReversed ? card.data.meaningRev : card.data.meaningUp}
                        </div>
                    </div>
                </div>
                <div class="history-timestamp">${timestamp}</div>
            `;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œç‚¹å‡»å†å²è®°å½•å¯ä»¥æŸ¥çœ‹å¡ç‰Œè¯¦æƒ…
            item.style.cursor = 'pointer';
            item.onclick = () => {
                this.cardPopup.show(card.data);
            };
            
            historyList.prepend(item);
        });

        // 2. ä¸ºæ¯å¼ é€‰ä¸­çš„å¡ç‰Œç”Ÿæˆç²’å­æ•ˆæœ
        selectedCards.forEach(card => {
            const particleCount = 1000; // æ¯å¼ å¡ç‰Œçš„ç²’å­æ•°é‡
            const geom = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            const velocityArray = new Float32Array(particleCount * 3); // é€Ÿåº¦
            
            const cardPos = card.mesh.position.clone();

            for(let i=0; i<particleCount; i++) {
                // åœ¨å¡ç‰Œä½“ç§¯å†…éšæœºé‡‡æ ·
                posArray[i*3] = cardPos.x + (Math.random() - 0.5) * 2;
                posArray[i*3+1] = cardPos.y + (Math.random() - 0.5) * 3.5;
                posArray[i*3+2] = cardPos.z + (Math.random() - 0.5) * 0.1;
                
                // å‘ä¸Šæ¼‚ç§»çš„éšæœºé€Ÿåº¦
                velocityArray[i*3] = (Math.random() - 0.5) * 0.05; // X æŠ–åŠ¨
                velocityArray[i*3+1] = Math.random() * 0.1 + 0.02; // Y ä¸Šå‡
                velocityArray[i*3+2] = (Math.random() - 0.5) * 0.05; // Z æŠ–åŠ¨
            }
            
            geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.08,
                transparent: true,
                opacity: 1
            });
            
            const particles = { mesh: new THREE.Points(geom, material), velocities: velocityArray, life: 1.0 };
            this.scene.add(particles.mesh);
            
            // å°†ç²’å­ç³»ç»Ÿæ·»åŠ åˆ°æ•°ç»„ä¸­ä»¥ä¾¿æ›´æ–°
            if (!this.particleSystems) {
                this.particleSystems = [];
            }
            this.particleSystems.push(particles);
            
            // éšè—åŸå¡ç‰Œ
            this.scene.remove(card.mesh);
        });

        // 3s åç”Ÿæˆæ–°å¡
        setTimeout(() => this.spawnCardRow(), 3000);
    }

    // æ›´æ–°æ‰€æœ‰ç²’å­ç³»ç»Ÿ
    updateParticles() {
        // æ›´æ–°ç°çƒ¬ç²’å­ç³»ç»Ÿ
        if (this.particleSystems) {
            for (let i = this.particleSystems.length - 1; i >= 0; i--) {
                const particleSystem = this.particleSystems[i];
                const positions = particleSystem.mesh.geometry.attributes.position.array;
                const vels = particleSystem.velocities;
                
                for(let j=0; j < positions.length / 3; j++) {
                    positions[j*3] += vels[j*3];     // X
                    positions[j*3+1] += vels[j*3+1]; // Y
                    positions[j*3+2] += vels[j*3+2]; // Z
                    
                    // å¢åŠ ä¸€ç‚¹å™ªç‚¹
                    vels[j*3] += (Math.random()-0.5) * 0.002;
                }
                particleSystem.mesh.geometry.attributes.position.needsUpdate = true;
                
                // è¡°å‡
                particleSystem.life -= 0.01;
                particleSystem.mesh.material.opacity = particleSystem.life;
                
                if (particleSystem.life <= 0) {
                    this.scene.remove(particleSystem.mesh);
                    this.particleSystems.splice(i, 1);
                }
            }
        }
        
        // æ›´æ–°åŸæœ‰çš„ç²’å­ç³»ç»Ÿï¼ˆå…¼å®¹æ—§ä»£ç ï¼‰
        if (this.particles) {
            const positions = this.particles.mesh.geometry.attributes.position.array;
            const vels = this.particles.velocities;
            
            for(let i=0; i < positions.length / 3; i++) {
                positions[i*3] += vels[i*3];     // X
                positions[i*3+1] += vels[i*3+1]; // Y
                positions[i*3+2] += vels[i*3+2]; // Z
                
                // å¢åŠ ä¸€ç‚¹å™ªç‚¹
                vels[i*3] += (Math.random()-0.5) * 0.002;
            }
            this.particles.mesh.geometry.attributes.position.needsUpdate = true;
            
            // è¡°å‡
            this.particles.life -= 0.01;
            this.particles.mesh.material.opacity = this.particles.life;
            
            if (this.particles.life <= 0) {
                this.scene.remove(this.particles.mesh);
                this.particles = null;
            }
        }
    }

    // --- ä¸»å¾ªç¯ ---
    animate() {
        requestAnimationFrame(() => this.animate());
        
        if (this.state === 'ASH_PHASE') {
            this.updateParticles();
        } else {
            // æ›´æ–°è½®æ¢ç²’å­æ•ˆæœ
            this.updateRotationParticles();
            // æ›´æ–°æ»‘åŠ¨ç²’å­æ•ˆæœ
            this.updateSwipeParticles();
            // æ›´æ–°å¡ç‰Œé«˜äº®æ•ˆæœ
            this.updateCardHighlight();
            
            // å¦‚æœæœ‰é€‰ä¸­çš„å¡ç‰Œä¸”å¤„äºPINCHçŠ¶æ€ï¼Œè®©å¡ç‰Œè·Ÿéšå…‰æ ‡
            if (this.selectedCardIndex >= 0 && this.selectedCardIndex < this.cardMeshes.length) {
                const selectedCard = this.cardMeshes[this.selectedCardIndex];
                
                if (this.gesture === 'PINCH' && !this.isDragging && !this.cardMeshes.some(c => c.isTransitioning)) {
                    // æŠ“å–æ¨¡å¼ï¼šé€‰ä¸­çš„å¡ç‰Œè·Ÿéšå…‰æ ‡ï¼ˆåªæœ‰åœ¨ä¸æ˜¯æ‹–æ‹½å¡ç‰Œè¡Œæ—¶ï¼‰
                    const targetX = this.cursor.x * 5;
                    const targetY = this.cursor.y * 3;
                    selectedCard.mesh.position.lerp(new THREE.Vector3(targetX, targetY, 2), 0.1);
                    
                    // åŠ¨æ€æ—‹è½¬è·Ÿéš
                    selectedCard.mesh.rotation.x = this.cursor.y * 0.5;
                    selectedCard.mesh.rotation.y = this.cursor.x * 0.5;
                    
                    this.state = 'GRABBING';
                } else if (this.gesture === 'FIST') {
                    // ç¡®è®¤æ¨¡å¼ï¼šé€‰æ‹©å½“å‰å¡ç‰Œ
                    this.selectCard(this.selectedCardIndex);
                } else {
                    // æ‚¬åœ/ç©ºé—²æ¨¡å¼ï¼šå¡ç‰Œå›åˆ°åŸä½ç½®
                    this.state = 'IDLE';
                }
            }
        }

        this.renderer.render(this.scene, this.camera);
    }

    toggleMode() {
        this.mode = this.mode === 'CAMERA' ? 'MOUSE' : 'CAMERA';
        document.getElementById('input-mode').innerText = this.mode === 'CAMERA' ? "æ‘„åƒå¤´" : "é¼ æ ‡";
    }
    
    // è®¾ç½®æ‘„åƒå¤´é¢„è§ˆ
    setupCameraPreview(stream) {
        this.cameraStream = stream;
        const previewVideo = document.getElementById('preview-video');
        
        if (stream && previewVideo) {
            previewVideo.srcObject = stream;
            // é»˜è®¤æ˜¾ç¤ºæ‘„åƒå¤´é¢„è§ˆ
            this.showCameraPreview();
        }
    }
    
    // æ˜¾ç¤ºæ‘„åƒå¤´é¢„è§ˆ
    showCameraPreview() {
        const preview = document.getElementById('camera-preview');
        if (preview && this.mode === 'CAMERA') {
            preview.classList.add('active');
            this.cameraPreviewVisible = true;
        }
    }
    
    // éšè—æ‘„åƒå¤´é¢„è§ˆ
    hideCameraPreview() {
        const preview = document.getElementById('camera-preview');
        if (preview) {
            preview.classList.remove('active');
            this.cameraPreviewVisible = false;
        }
    }
    
    // åˆ‡æ¢æ‘„åƒå¤´é¢„è§ˆæ˜¾ç¤º/éšè—
    toggleCameraPreview() {
        if (this.cameraPreviewVisible) {
            this.hideCameraPreview();
        } else {
            this.showCameraPreview();
        }
    }

    updateUI() {
        const indicator = document.getElementById('gesture-indicator');
        const desc = document.getElementById('card-desc');
        
        indicator.innerText = this.gesture;
        
        // æ ¹æ®æ–°çš„ä¸‰å±‚çŠ¶æ€æœºæ›´æ–°UI
        if (this.gestureState === 'DOUBLE_OPEN_PALM') {
            indicator.style.color = '#ff00ff';
            indicator.innerText = 'ğŸ™Œ åŒæ‰‹å¼ å¼€';
            desc.innerText = "åŒæ‰‹å¼ å¼€: è¶…çº§è½®è½¬æ¨¡å¼<br>å¿«é€ŸæŒ¥åŠ¨åŒæ‰‹è¿›è¡Œé«˜é€Ÿè½®è½¬<br>è½®è½¬èŒƒå›´æ›´å¤§ï¼Œæ•ˆæœæ›´éœ‡æ’¼";
        } else if (this.gestureState === 'OPEN_PALM') {
            indicator.style.color = '#00ffcc';
            indicator.innerText = 'âœ‹ å¼ å¼€';
            desc.innerText = "äº”æŒ‡å¼ å¼€: æµè§ˆ/è½®è½¬æ¨¡å¼<br>å·¦å³æŒ¥åŠ¨æ‰‹æŒè½®æ¢å¡ç‰Œ<br>åŒå‡»æˆ–ç‚¹å‡»å±•ç¤ºæ¡†æŸ¥çœ‹å¡ç‰Œè¯¦æƒ…";
        } else if (this.gestureState === 'POINT') {
            indicator.style.color = '#ff9900';
            indicator.innerText = 'â˜ï¸ æŒ‡å‘';
            desc.innerText = "é£ŸæŒ‡æŒ‡å‘: ç„å‡†/æ‚¬åœæ¨¡å¼<br>ç§»åŠ¨é£ŸæŒ‡é€‰æ‹©å¡ç‰Œ<br>æåˆç¡®è®¤é€‰æ‹©";
        } else if (this.gestureState === 'PINCH') {
            indicator.style.color = '#ffff00';
            indicator.innerText = 'ğŸ‘Œ æåˆ';
            if (this.wasPinching) {
                const pinchDuration = Date.now() - this.pinchStartTime;
                const remainingTime = Math.max(0, this.pinchConfirmTime - pinchDuration);
                desc.innerText = `æåˆ: æŠ“å–/ç¡®è®¤æ¨¡å¼<br>ä¿æŒæåˆ ${Math.ceil(remainingTime/1000)} ç§’æˆ–å‘ä¸‹æ‹–æ‹½ç¡®è®¤<br>åŒå‡»æˆ–ç‚¹å‡»å±•ç¤ºæ¡†æŸ¥çœ‹å¡ç‰Œè¯¦æƒ…`;
            } else {
                desc.innerText = "æåˆ: æŠ“å–/ç¡®è®¤æ¨¡å¼<br>ä¿æŒæåˆ1ç§’æˆ–å‘ä¸‹æ‹–æ‹½ç¡®è®¤<br>åŒå‡»æˆ–ç‚¹å‡»å±•ç¤ºæ¡†æŸ¥çœ‹å¡ç‰Œè¯¦æƒ…";
            }
        }
        
        // æ˜¾ç¤ºå½“å‰é€‰ä¸­çš„å¡ç‰Œä¿¡æ¯
        if (this.selectedCardIndex >= 0 && this.selectedCardIndex < this.cardMeshes.length) {
            const card = this.cardMeshes[this.selectedCardIndex].data;
            desc.innerText += `<br><br>é€‰ä¸­: ${card.name}`;
        }
    }
}

// å¯åŠ¨åº”ç”¨
const app = new TarotApp();

</script>
</body>
</html>